// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "tinytable.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace tinytable {

namespace {

const ::google::protobuf::Descriptor* columns_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  columns_reflection_ = NULL;
const ::google::protobuf::Descriptor* column_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  column_reflection_ = NULL;
const ::google::protobuf::Descriptor* col_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  col_reflection_ = NULL;
const ::google::protobuf::Descriptor* cols_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  cols_reflection_ = NULL;
const ::google::protobuf::Descriptor* uniques_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  uniques_reflection_ = NULL;
const ::google::protobuf::Descriptor* unique_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  unique_reflection_ = NULL;
const ::google::protobuf::Descriptor* master_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  master_reflection_ = NULL;
const ::google::protobuf::Descriptor* slave_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  slave_reflection_ = NULL;
const ::google::protobuf::Descriptor* cluster_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  cluster_reflection_ = NULL;
const ::google::protobuf::Descriptor* clusters_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  clusters_reflection_ = NULL;
const ::google::protobuf::Descriptor* sort_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  sort_reflection_ = NULL;
const ::google::protobuf::Descriptor* sorts_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  sorts_reflection_ = NULL;
const ::google::protobuf::Descriptor* queue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  queue_reflection_ = NULL;
const ::google::protobuf::Descriptor* queues_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  queues_reflection_ = NULL;
const ::google::protobuf::Descriptor* condition_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  condition_reflection_ = NULL;
const ::google::protobuf::Descriptor* colfunc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  colfunc_reflection_ = NULL;
const ::google::protobuf::Descriptor* func_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  func_reflection_ = NULL;
const ::google::protobuf::Descriptor* timertrigger_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  timertrigger_reflection_ = NULL;
const ::google::protobuf::Descriptor* timertriggers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  timertriggers_reflection_ = NULL;
const ::google::protobuf::Descriptor* triggers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  triggers_reflection_ = NULL;
const ::google::protobuf::Descriptor* tinytable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  tinytable_reflection_ = NULL;
const ::google::protobuf::Descriptor* table_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  table_reflection_ = NULL;
const ::google::protobuf::Descriptor* tables_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  tables_reflection_ = NULL;
const ::google::protobuf::Descriptor* tablecol_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  tablecol_reflection_ = NULL;
const ::google::protobuf::Descriptor* tablecols_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  tablecols_reflection_ = NULL;
const ::google::protobuf::Descriptor* expire_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  expire_reflection_ = NULL;
const ::google::protobuf::Descriptor* expires_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  expires_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_tinytable_2eproto() {
  protobuf_AddDesc_tinytable_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "tinytable.proto");
  GOOGLE_CHECK(file != NULL);
  columns_descriptor_ = file->message_type(0);
  static const int columns_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(columns, column_),
  };
  columns_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      columns_descriptor_,
      columns::default_instance_,
      columns_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(columns, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(columns, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(columns));
  column_descriptor_ = file->message_type(1);
  static const int column_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(column, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(column, datatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(column, maxlen_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(column, is_primary_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(column, desc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(column, serial_),
  };
  column_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      column_descriptor_,
      column::default_instance_,
      column_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(column, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(column, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(column));
  col_descriptor_ = file->message_type(2);
  static const int col_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(col, name_),
  };
  col_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      col_descriptor_,
      col::default_instance_,
      col_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(col, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(col, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(col));
  cols_descriptor_ = file->message_type(3);
  static const int cols_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cols, col_),
  };
  cols_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      cols_descriptor_,
      cols::default_instance_,
      cols_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cols, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cols, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(cols));
  uniques_descriptor_ = file->message_type(4);
  static const int uniques_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(uniques, unique_),
  };
  uniques_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      uniques_descriptor_,
      uniques::default_instance_,
      uniques_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(uniques, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(uniques, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(uniques));
  unique_descriptor_ = file->message_type(5);
  static const int unique_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unique, col_),
  };
  unique_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      unique_descriptor_,
      unique::default_instance_,
      unique_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unique, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unique, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(unique));
  master_descriptor_ = file->message_type(6);
  static const int master_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(master, col_),
  };
  master_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      master_descriptor_,
      master::default_instance_,
      master_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(master, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(master, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(master));
  slave_descriptor_ = file->message_type(7);
  static const int slave_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(slave, col_),
  };
  slave_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      slave_descriptor_,
      slave::default_instance_,
      slave_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(slave, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(slave, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(slave));
  cluster_descriptor_ = file->message_type(8);
  static const int cluster_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cluster, master_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cluster, slave_),
  };
  cluster_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      cluster_descriptor_,
      cluster::default_instance_,
      cluster_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cluster, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(cluster, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(cluster));
  clusters_descriptor_ = file->message_type(9);
  static const int clusters_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(clusters, cluster_),
  };
  clusters_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      clusters_descriptor_,
      clusters::default_instance_,
      clusters_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(clusters, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(clusters, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(clusters));
  sort_descriptor_ = file->message_type(10);
  static const int sort_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(sort, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(sort, master_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(sort, slave_),
  };
  sort_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      sort_descriptor_,
      sort::default_instance_,
      sort_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(sort, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(sort, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(sort));
  sorts_descriptor_ = file->message_type(11);
  static const int sorts_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(sorts, sort_),
  };
  sorts_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      sorts_descriptor_,
      sorts::default_instance_,
      sorts_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(sorts, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(sorts, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(sorts));
  queue_descriptor_ = file->message_type(12);
  static const int queue_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(queue, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(queue, max_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(queue, master_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(queue, slave_),
  };
  queue_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      queue_descriptor_,
      queue::default_instance_,
      queue_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(queue, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(queue, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(queue));
  queues_descriptor_ = file->message_type(13);
  static const int queues_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(queues, queue_),
  };
  queues_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      queues_descriptor_,
      queues::default_instance_,
      queues_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(queues, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(queues, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(queues));
  condition_descriptor_ = file->message_type(14);
  static const int condition_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(condition, interval_s_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(condition, interval_ms_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(condition, weekday_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(condition, hour_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(condition, minute_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(condition, second_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(condition, desc_),
  };
  condition_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      condition_descriptor_,
      condition::default_instance_,
      condition_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(condition, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(condition, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(condition));
  colfunc_descriptor_ = file->message_type(15);
  static const int colfunc_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(colfunc, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(colfunc, ops_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(colfunc, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(colfunc, desc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(colfunc, min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(colfunc, max_),
  };
  colfunc_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      colfunc_descriptor_,
      colfunc::default_instance_,
      colfunc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(colfunc, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(colfunc, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(colfunc));
  func_descriptor_ = file->message_type(16);
  static const int func_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(func, colfunc_),
  };
  func_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      func_descriptor_,
      func::default_instance_,
      func_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(func, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(func, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(func));
  timertrigger_descriptor_ = file->message_type(17);
  static const int timertrigger_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertrigger, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertrigger, desc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertrigger, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertrigger, timecol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertrigger, condition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertrigger, func_),
  };
  timertrigger_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      timertrigger_descriptor_,
      timertrigger::default_instance_,
      timertrigger_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertrigger, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertrigger, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(timertrigger));
  timertriggers_descriptor_ = file->message_type(18);
  static const int timertriggers_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertriggers, timertrigger_),
  };
  timertriggers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      timertriggers_descriptor_,
      timertriggers::default_instance_,
      timertriggers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertriggers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(timertriggers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(timertriggers));
  triggers_descriptor_ = file->message_type(19);
  static const int triggers_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(triggers, timertriggers_),
  };
  triggers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      triggers_descriptor_,
      triggers::default_instance_,
      triggers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(triggers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(triggers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(triggers));
  tinytable_descriptor_ = file->message_type(20);
  static const int tinytable_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, desc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, servercol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, expired_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, loadtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, firstsource_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, updatetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, columns_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, uniques_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, clusters_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, sorts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, triggers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, queues_),
  };
  tinytable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      tinytable_descriptor_,
      tinytable::default_instance_,
      tinytable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tinytable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(tinytable));
  table_descriptor_ = file->message_type(21);
  static const int table_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(table, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(table, update_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(table, save_),
  };
  table_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      table_descriptor_,
      table::default_instance_,
      table_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(table, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(table, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(table));
  tables_descriptor_ = file->message_type(22);
  static const int tables_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tables, table_),
  };
  tables_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      tables_descriptor_,
      tables::default_instance_,
      tables_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tables, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tables, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(tables));
  tablecol_descriptor_ = file->message_type(23);
  static const int tablecol_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tablecol, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tablecol, cols_),
  };
  tablecol_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      tablecol_descriptor_,
      tablecol::default_instance_,
      tablecol_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tablecol, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tablecol, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(tablecol));
  tablecols_descriptor_ = file->message_type(24);
  static const int tablecols_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tablecols, tablecol_),
  };
  tablecols_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      tablecols_descriptor_,
      tablecols::default_instance_,
      tablecols_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tablecols, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(tablecols, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(tablecols));
  expire_descriptor_ = file->message_type(25);
  static const int expire_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(expire, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(expire, timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(expire, tablecols_),
  };
  expire_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      expire_descriptor_,
      expire::default_instance_,
      expire_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(expire, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(expire, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(expire));
  expires_descriptor_ = file->message_type(26);
  static const int expires_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(expires, expire_),
  };
  expires_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      expires_descriptor_,
      expires::default_instance_,
      expires_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(expires, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(expires, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(expires));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_tinytable_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    columns_descriptor_, &columns::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    column_descriptor_, &column::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    col_descriptor_, &col::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    cols_descriptor_, &cols::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    uniques_descriptor_, &uniques::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    unique_descriptor_, &unique::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    master_descriptor_, &master::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    slave_descriptor_, &slave::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    cluster_descriptor_, &cluster::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    clusters_descriptor_, &clusters::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    sort_descriptor_, &sort::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    sorts_descriptor_, &sorts::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    queue_descriptor_, &queue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    queues_descriptor_, &queues::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    condition_descriptor_, &condition::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    colfunc_descriptor_, &colfunc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    func_descriptor_, &func::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    timertrigger_descriptor_, &timertrigger::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    timertriggers_descriptor_, &timertriggers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    triggers_descriptor_, &triggers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    tinytable_descriptor_, &tinytable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    table_descriptor_, &table::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    tables_descriptor_, &tables::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    tablecol_descriptor_, &tablecol::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    tablecols_descriptor_, &tablecols::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    expire_descriptor_, &expire::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    expires_descriptor_, &expires::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_tinytable_2eproto() {
  delete columns::default_instance_;
  delete columns_reflection_;
  delete column::default_instance_;
  delete column_reflection_;
  delete col::default_instance_;
  delete col_reflection_;
  delete cols::default_instance_;
  delete cols_reflection_;
  delete uniques::default_instance_;
  delete uniques_reflection_;
  delete unique::default_instance_;
  delete unique_reflection_;
  delete master::default_instance_;
  delete master_reflection_;
  delete slave::default_instance_;
  delete slave_reflection_;
  delete cluster::default_instance_;
  delete cluster_reflection_;
  delete clusters::default_instance_;
  delete clusters_reflection_;
  delete sort::default_instance_;
  delete sort_reflection_;
  delete sorts::default_instance_;
  delete sorts_reflection_;
  delete queue::default_instance_;
  delete queue_reflection_;
  delete queues::default_instance_;
  delete queues_reflection_;
  delete condition::default_instance_;
  delete condition_reflection_;
  delete colfunc::default_instance_;
  delete colfunc_reflection_;
  delete func::default_instance_;
  delete func_reflection_;
  delete timertrigger::default_instance_;
  delete timertrigger_reflection_;
  delete timertriggers::default_instance_;
  delete timertriggers_reflection_;
  delete triggers::default_instance_;
  delete triggers_reflection_;
  delete tinytable::default_instance_;
  delete tinytable_reflection_;
  delete table::default_instance_;
  delete table_reflection_;
  delete tables::default_instance_;
  delete tables_reflection_;
  delete tablecol::default_instance_;
  delete tablecol_reflection_;
  delete tablecols::default_instance_;
  delete tablecols_reflection_;
  delete expire::default_instance_;
  delete expire_reflection_;
  delete expires::default_instance_;
  delete expires_reflection_;
}

void protobuf_AddDesc_tinytable_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017tinytable.proto\022\ttinytable\",\n\007columns\022"
    "!\n\006column\030\001 \003(\0132\021.tinytable.column\"j\n\006co"
    "lumn\022\014\n\004name\030\001 \002(\t\022\020\n\010datatype\030\002 \002(\t\022\016\n\006"
    "maxlen\030\003 \001(\005\022\022\n\nis_primary\030\004 \001(\010\022\014\n\004desc"
    "\030\005 \001(\t\022\016\n\006serial\030\006 \001(\005\"\023\n\003col\022\014\n\004name\030\001 "
    "\002(\t\"#\n\004cols\022\033\n\003col\030\001 \003(\0132\016.tinytable.col"
    "\",\n\007uniques\022!\n\006unique\030\001 \003(\0132\021.tinytable."
    "unique\"%\n\006unique\022\033\n\003col\030\001 \003(\0132\016.tinytabl"
    "e.col\"%\n\006master\022\033\n\003col\030\001 \003(\0132\016.tinytable"
    ".col\"$\n\005slave\022\033\n\003col\030\001 \003(\0132\016.tinytable.c"
    "ol\"M\n\007cluster\022!\n\006master\030\001 \002(\0132\021.tinytabl"
    "e.master\022\037\n\005slave\030\002 \002(\0132\020.tinytable.slav"
    "e\"/\n\010clusters\022#\n\007cluster\030\001 \003(\0132\022.tinytab"
    "le.cluster\"X\n\004sort\022\014\n\004type\030\001 \001(\t\022!\n\006mast"
    "er\030\002 \001(\0132\021.tinytable.master\022\037\n\005slave\030\003 \001"
    "(\0132\020.tinytable.slave\"&\n\005sorts\022\035\n\004sort\030\001 "
    "\003(\0132\017.tinytable.sort\"k\n\005queue\022\014\n\004type\030\001 "
    "\001(\t\022\020\n\010max_size\030\002 \001(\005\022!\n\006master\030\003 \001(\0132\021."
    "tinytable.master\022\037\n\005slave\030\004 \001(\0132\020.tinyta"
    "ble.slave\")\n\006queues\022\037\n\005queue\030\001 \003(\0132\020.tin"
    "ytable.queue\"\201\001\n\tcondition\022\022\n\ninterval_s"
    "\030\001 \001(\005\022\023\n\013interval_ms\030\002 \001(\005\022\017\n\007weekday\030\003"
    " \001(\005\022\014\n\004hour\030\004 \001(\005\022\016\n\006minute\030\005 \001(\005\022\016\n\006se"
    "cond\030\006 \001(\005\022\014\n\004desc\030\007 \001(\t\"`\n\007colfunc\022\014\n\004n"
    "ame\030\001 \001(\t\022\020\n\010ops_type\030\002 \002(\t\022\r\n\005value\030\003 \001"
    "(\t\022\014\n\004desc\030\004 \001(\t\022\013\n\003min\030\005 \001(\t\022\013\n\003max\030\006 \001"
    "(\t\"+\n\004func\022#\n\007colfunc\030\001 \003(\0132\022.tinytable."
    "colfunc\"\221\001\n\014timertrigger\022\014\n\004name\030\001 \001(\t\022\014"
    "\n\004desc\030\002 \001(\t\022\014\n\004type\030\003 \002(\t\022\017\n\007timecol\030\004 "
    "\002(\t\022\'\n\tcondition\030\005 \002(\0132\024.tinytable.condi"
    "tion\022\035\n\004func\030\006 \002(\0132\017.tinytable.func\">\n\rt"
    "imertriggers\022-\n\014timertrigger\030\001 \003(\0132\027.tin"
    "ytable.timertrigger\";\n\010triggers\022/\n\rtimer"
    "triggers\030\001 \001(\0132\030.tinytable.timertriggers"
    "\"\360\002\n\ttinytable\022\014\n\004name\030\001 \002(\t\022\014\n\004desc\030\002 \001"
    "(\t\022\021\n\tservercol\030\003 \001(\t\022\017\n\007expired\030\004 \002(\005\022\020"
    "\n\010loadtype\030\005 \001(\t\022\014\n\004type\030\006 \001(\t\022\023\n\013firsts"
    "ource\030\007 \001(\t\022\022\n\nupdatetype\030\010 \001(\t\022#\n\007colum"
    "ns\030\t \001(\0132\022.tinytable.columns\022#\n\007uniques\030"
    "\n \001(\0132\022.tinytable.uniques\022%\n\010clusters\030\013 "
    "\001(\0132\023.tinytable.clusters\022\037\n\005sorts\030\014 \001(\0132"
    "\020.tinytable.sorts\022%\n\010triggers\030\r \001(\0132\023.ti"
    "nytable.triggers\022!\n\006queues\030\016 \001(\0132\021.tinyt"
    "able.queues\"8\n\005table\022\014\n\004name\030\001 \002(\t\022\023\n\013up"
    "date_type\030\002 \001(\t\022\014\n\004save\030\003 \001(\005\")\n\006tables\022"
    "\037\n\005table\030\001 \003(\0132\020.tinytable.table\"7\n\010tabl"
    "ecol\022\014\n\004name\030\001 \002(\t\022\035\n\004cols\030\002 \002(\0132\017.tinyt"
    "able.cols\"2\n\ttablecols\022%\n\010tablecol\030\001 \003(\013"
    "2\023.tinytable.tablecol\"P\n\006expire\022\014\n\004name\030"
    "\001 \002(\t\022\017\n\007timeout\030\002 \002(\005\022\'\n\ttablecols\030\003 \002("
    "\0132\024.tinytable.tablecols\",\n\007expires\022!\n\006ex"
    "pire\030\001 \003(\0132\021.tinytable.expire", 2069);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "tinytable.proto", &protobuf_RegisterTypes);
  columns::default_instance_ = new columns();
  column::default_instance_ = new column();
  col::default_instance_ = new col();
  cols::default_instance_ = new cols();
  uniques::default_instance_ = new uniques();
  unique::default_instance_ = new unique();
  master::default_instance_ = new master();
  slave::default_instance_ = new slave();
  cluster::default_instance_ = new cluster();
  clusters::default_instance_ = new clusters();
  sort::default_instance_ = new sort();
  sorts::default_instance_ = new sorts();
  queue::default_instance_ = new queue();
  queues::default_instance_ = new queues();
  condition::default_instance_ = new condition();
  colfunc::default_instance_ = new colfunc();
  func::default_instance_ = new func();
  timertrigger::default_instance_ = new timertrigger();
  timertriggers::default_instance_ = new timertriggers();
  triggers::default_instance_ = new triggers();
  tinytable::default_instance_ = new tinytable();
  table::default_instance_ = new table();
  tables::default_instance_ = new tables();
  tablecol::default_instance_ = new tablecol();
  tablecols::default_instance_ = new tablecols();
  expire::default_instance_ = new expire();
  expires::default_instance_ = new expires();
  columns::default_instance_->InitAsDefaultInstance();
  column::default_instance_->InitAsDefaultInstance();
  col::default_instance_->InitAsDefaultInstance();
  cols::default_instance_->InitAsDefaultInstance();
  uniques::default_instance_->InitAsDefaultInstance();
  unique::default_instance_->InitAsDefaultInstance();
  master::default_instance_->InitAsDefaultInstance();
  slave::default_instance_->InitAsDefaultInstance();
  cluster::default_instance_->InitAsDefaultInstance();
  clusters::default_instance_->InitAsDefaultInstance();
  sort::default_instance_->InitAsDefaultInstance();
  sorts::default_instance_->InitAsDefaultInstance();
  queue::default_instance_->InitAsDefaultInstance();
  queues::default_instance_->InitAsDefaultInstance();
  condition::default_instance_->InitAsDefaultInstance();
  colfunc::default_instance_->InitAsDefaultInstance();
  func::default_instance_->InitAsDefaultInstance();
  timertrigger::default_instance_->InitAsDefaultInstance();
  timertriggers::default_instance_->InitAsDefaultInstance();
  triggers::default_instance_->InitAsDefaultInstance();
  tinytable::default_instance_->InitAsDefaultInstance();
  table::default_instance_->InitAsDefaultInstance();
  tables::default_instance_->InitAsDefaultInstance();
  tablecol::default_instance_->InitAsDefaultInstance();
  tablecols::default_instance_->InitAsDefaultInstance();
  expire::default_instance_->InitAsDefaultInstance();
  expires::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_tinytable_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_tinytable_2eproto {
  StaticDescriptorInitializer_tinytable_2eproto() {
    protobuf_AddDesc_tinytable_2eproto();
  }
} static_descriptor_initializer_tinytable_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int columns::kColumnFieldNumber;
#endif  // !_MSC_VER

columns::columns()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void columns::InitAsDefaultInstance() {
}

columns::columns(const columns& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void columns::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

columns::~columns() {
  SharedDtor();
}

void columns::SharedDtor() {
  if (this != default_instance_) {
  }
}

void columns::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* columns::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return columns_descriptor_;
}

const columns& columns::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

columns* columns::default_instance_ = NULL;

columns* columns::New() const {
  return new columns;
}

void columns::Clear() {
  column_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool columns::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.column column = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_column:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_column()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_column;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void columns::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.column column = 1;
  for (int i = 0; i < this->column_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->column(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* columns::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.column column = 1;
  for (int i = 0; i < this->column_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->column(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int columns::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.column column = 1;
  total_size += 1 * this->column_size();
  for (int i = 0; i < this->column_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->column(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void columns::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const columns* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const columns*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void columns::MergeFrom(const columns& from) {
  GOOGLE_CHECK_NE(&from, this);
  column_.MergeFrom(from.column_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void columns::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void columns::CopyFrom(const columns& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool columns::IsInitialized() const {
  
  for (int i = 0; i < column_size(); i++) {
    if (!this->column(i).IsInitialized()) return false;
  }
  return true;
}

void columns::Swap(columns* other) {
  if (other != this) {
    column_.Swap(&other->column_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata columns::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = columns_descriptor_;
  metadata.reflection = columns_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string column::_default_name_;
const ::std::string column::_default_datatype_;
const ::std::string column::_default_desc_;
#ifndef _MSC_VER
const int column::kNameFieldNumber;
const int column::kDatatypeFieldNumber;
const int column::kMaxlenFieldNumber;
const int column::kIsPrimaryFieldNumber;
const int column::kDescFieldNumber;
const int column::kSerialFieldNumber;
#endif  // !_MSC_VER

column::column()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void column::InitAsDefaultInstance() {
}

column::column(const column& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void column::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  datatype_ = const_cast< ::std::string*>(&_default_datatype_);
  maxlen_ = 0;
  is_primary_ = false;
  desc_ = const_cast< ::std::string*>(&_default_desc_);
  serial_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

column::~column() {
  SharedDtor();
}

void column::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (datatype_ != &_default_datatype_) {
    delete datatype_;
  }
  if (desc_ != &_default_desc_) {
    delete desc_;
  }
  if (this != default_instance_) {
  }
}

void column::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* column::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return column_descriptor_;
}

const column& column::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

column* column::default_instance_ = NULL;

column* column::New() const {
  return new column;
}

void column::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (datatype_ != &_default_datatype_) {
        datatype_->clear();
      }
    }
    maxlen_ = 0;
    is_primary_ = false;
    if (_has_bit(4)) {
      if (desc_ != &_default_desc_) {
        desc_->clear();
      }
    }
    serial_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool column::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_datatype;
        break;
      }
      
      // required string datatype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_datatype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_datatype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->datatype().data(), this->datatype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_maxlen;
        break;
      }
      
      // optional int32 maxlen = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxlen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxlen_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_primary;
        break;
      }
      
      // optional bool is_primary = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_primary:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_primary_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_desc;
        break;
      }
      
      // optional string desc = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->desc().data(), this->desc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_serial;
        break;
      }
      
      // optional int32 serial = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_serial:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &serial_)));
          _set_bit(5);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void column::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required string datatype = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->datatype().data(), this->datatype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->datatype(), output);
  }
  
  // optional int32 maxlen = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->maxlen(), output);
  }
  
  // optional bool is_primary = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->is_primary(), output);
  }
  
  // optional string desc = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->desc(), output);
  }
  
  // optional int32 serial = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->serial(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* column::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required string datatype = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->datatype().data(), this->datatype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->datatype(), target);
  }
  
  // optional int32 maxlen = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->maxlen(), target);
  }
  
  // optional bool is_primary = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->is_primary(), target);
  }
  
  // optional string desc = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->desc(), target);
  }
  
  // optional int32 serial = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->serial(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int column::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required string datatype = 2;
    if (has_datatype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->datatype());
    }
    
    // optional int32 maxlen = 3;
    if (has_maxlen()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxlen());
    }
    
    // optional bool is_primary = 4;
    if (has_is_primary()) {
      total_size += 1 + 1;
    }
    
    // optional string desc = 5;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }
    
    // optional int32 serial = 6;
    if (has_serial()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->serial());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void column::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const column* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const column*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void column::MergeFrom(const column& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
    if (from._has_bit(1)) {
      set_datatype(from.datatype());
    }
    if (from._has_bit(2)) {
      set_maxlen(from.maxlen());
    }
    if (from._has_bit(3)) {
      set_is_primary(from.is_primary());
    }
    if (from._has_bit(4)) {
      set_desc(from.desc());
    }
    if (from._has_bit(5)) {
      set_serial(from.serial());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void column::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void column::CopyFrom(const column& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool column::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void column::Swap(column* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(datatype_, other->datatype_);
    std::swap(maxlen_, other->maxlen_);
    std::swap(is_primary_, other->is_primary_);
    std::swap(desc_, other->desc_);
    std::swap(serial_, other->serial_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata column::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = column_descriptor_;
  metadata.reflection = column_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string col::_default_name_;
#ifndef _MSC_VER
const int col::kNameFieldNumber;
#endif  // !_MSC_VER

col::col()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void col::InitAsDefaultInstance() {
}

col::col(const col& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void col::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

col::~col() {
  SharedDtor();
}

void col::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void col::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* col::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return col_descriptor_;
}

const col& col::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

col* col::default_instance_ = NULL;

col* col::New() const {
  return new col;
}

void col::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool col::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void col::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* col::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int col::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void col::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const col* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const col*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void col::MergeFrom(const col& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void col::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void col::CopyFrom(const col& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool col::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void col::Swap(col* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata col::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = col_descriptor_;
  metadata.reflection = col_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int cols::kColFieldNumber;
#endif  // !_MSC_VER

cols::cols()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void cols::InitAsDefaultInstance() {
}

cols::cols(const cols& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void cols::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

cols::~cols() {
  SharedDtor();
}

void cols::SharedDtor() {
  if (this != default_instance_) {
  }
}

void cols::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* cols::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return cols_descriptor_;
}

const cols& cols::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

cols* cols::default_instance_ = NULL;

cols* cols::New() const {
  return new cols;
}

void cols::Clear() {
  col_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool cols::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.col col = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_col:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_col()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_col;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void cols::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.col col = 1;
  for (int i = 0; i < this->col_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->col(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* cols::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.col col = 1;
  for (int i = 0; i < this->col_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->col(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int cols::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.col col = 1;
  total_size += 1 * this->col_size();
  for (int i = 0; i < this->col_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->col(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void cols::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const cols* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const cols*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void cols::MergeFrom(const cols& from) {
  GOOGLE_CHECK_NE(&from, this);
  col_.MergeFrom(from.col_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void cols::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void cols::CopyFrom(const cols& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool cols::IsInitialized() const {
  
  for (int i = 0; i < col_size(); i++) {
    if (!this->col(i).IsInitialized()) return false;
  }
  return true;
}

void cols::Swap(cols* other) {
  if (other != this) {
    col_.Swap(&other->col_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata cols::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = cols_descriptor_;
  metadata.reflection = cols_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int uniques::kUniqueFieldNumber;
#endif  // !_MSC_VER

uniques::uniques()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void uniques::InitAsDefaultInstance() {
}

uniques::uniques(const uniques& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void uniques::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

uniques::~uniques() {
  SharedDtor();
}

void uniques::SharedDtor() {
  if (this != default_instance_) {
  }
}

void uniques::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* uniques::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return uniques_descriptor_;
}

const uniques& uniques::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

uniques* uniques::default_instance_ = NULL;

uniques* uniques::New() const {
  return new uniques;
}

void uniques::Clear() {
  unique_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool uniques::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.unique unique = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_unique:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_unique()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_unique;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void uniques::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.unique unique = 1;
  for (int i = 0; i < this->unique_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->unique(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* uniques::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.unique unique = 1;
  for (int i = 0; i < this->unique_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->unique(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int uniques::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.unique unique = 1;
  total_size += 1 * this->unique_size();
  for (int i = 0; i < this->unique_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->unique(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void uniques::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const uniques* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const uniques*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void uniques::MergeFrom(const uniques& from) {
  GOOGLE_CHECK_NE(&from, this);
  unique_.MergeFrom(from.unique_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void uniques::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void uniques::CopyFrom(const uniques& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool uniques::IsInitialized() const {
  
  for (int i = 0; i < unique_size(); i++) {
    if (!this->unique(i).IsInitialized()) return false;
  }
  return true;
}

void uniques::Swap(uniques* other) {
  if (other != this) {
    unique_.Swap(&other->unique_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata uniques::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = uniques_descriptor_;
  metadata.reflection = uniques_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int unique::kColFieldNumber;
#endif  // !_MSC_VER

unique::unique()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void unique::InitAsDefaultInstance() {
}

unique::unique(const unique& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void unique::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

unique::~unique() {
  SharedDtor();
}

void unique::SharedDtor() {
  if (this != default_instance_) {
  }
}

void unique::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* unique::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return unique_descriptor_;
}

const unique& unique::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

unique* unique::default_instance_ = NULL;

unique* unique::New() const {
  return new unique;
}

void unique::Clear() {
  col_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool unique::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.col col = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_col:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_col()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_col;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void unique::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.col col = 1;
  for (int i = 0; i < this->col_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->col(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* unique::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.col col = 1;
  for (int i = 0; i < this->col_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->col(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int unique::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.col col = 1;
  total_size += 1 * this->col_size();
  for (int i = 0; i < this->col_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->col(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void unique::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const unique* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const unique*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void unique::MergeFrom(const unique& from) {
  GOOGLE_CHECK_NE(&from, this);
  col_.MergeFrom(from.col_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void unique::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void unique::CopyFrom(const unique& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool unique::IsInitialized() const {
  
  for (int i = 0; i < col_size(); i++) {
    if (!this->col(i).IsInitialized()) return false;
  }
  return true;
}

void unique::Swap(unique* other) {
  if (other != this) {
    col_.Swap(&other->col_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata unique::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = unique_descriptor_;
  metadata.reflection = unique_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int master::kColFieldNumber;
#endif  // !_MSC_VER

master::master()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void master::InitAsDefaultInstance() {
}

master::master(const master& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void master::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

master::~master() {
  SharedDtor();
}

void master::SharedDtor() {
  if (this != default_instance_) {
  }
}

void master::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* master::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return master_descriptor_;
}

const master& master::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

master* master::default_instance_ = NULL;

master* master::New() const {
  return new master;
}

void master::Clear() {
  col_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool master::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.col col = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_col:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_col()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_col;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void master::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.col col = 1;
  for (int i = 0; i < this->col_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->col(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* master::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.col col = 1;
  for (int i = 0; i < this->col_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->col(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int master::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.col col = 1;
  total_size += 1 * this->col_size();
  for (int i = 0; i < this->col_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->col(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void master::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const master* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const master*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void master::MergeFrom(const master& from) {
  GOOGLE_CHECK_NE(&from, this);
  col_.MergeFrom(from.col_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void master::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void master::CopyFrom(const master& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool master::IsInitialized() const {
  
  for (int i = 0; i < col_size(); i++) {
    if (!this->col(i).IsInitialized()) return false;
  }
  return true;
}

void master::Swap(master* other) {
  if (other != this) {
    col_.Swap(&other->col_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata master::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = master_descriptor_;
  metadata.reflection = master_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int slave::kColFieldNumber;
#endif  // !_MSC_VER

slave::slave()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void slave::InitAsDefaultInstance() {
}

slave::slave(const slave& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void slave::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

slave::~slave() {
  SharedDtor();
}

void slave::SharedDtor() {
  if (this != default_instance_) {
  }
}

void slave::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* slave::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return slave_descriptor_;
}

const slave& slave::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

slave* slave::default_instance_ = NULL;

slave* slave::New() const {
  return new slave;
}

void slave::Clear() {
  col_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool slave::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.col col = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_col:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_col()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_col;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void slave::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.col col = 1;
  for (int i = 0; i < this->col_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->col(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* slave::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.col col = 1;
  for (int i = 0; i < this->col_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->col(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int slave::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.col col = 1;
  total_size += 1 * this->col_size();
  for (int i = 0; i < this->col_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->col(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void slave::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const slave* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const slave*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void slave::MergeFrom(const slave& from) {
  GOOGLE_CHECK_NE(&from, this);
  col_.MergeFrom(from.col_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void slave::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void slave::CopyFrom(const slave& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool slave::IsInitialized() const {
  
  for (int i = 0; i < col_size(); i++) {
    if (!this->col(i).IsInitialized()) return false;
  }
  return true;
}

void slave::Swap(slave* other) {
  if (other != this) {
    col_.Swap(&other->col_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata slave::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = slave_descriptor_;
  metadata.reflection = slave_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int cluster::kMasterFieldNumber;
const int cluster::kSlaveFieldNumber;
#endif  // !_MSC_VER

cluster::cluster()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void cluster::InitAsDefaultInstance() {
  master_ = const_cast< ::tinytable::master*>(&::tinytable::master::default_instance());
  slave_ = const_cast< ::tinytable::slave*>(&::tinytable::slave::default_instance());
}

cluster::cluster(const cluster& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void cluster::SharedCtor() {
  _cached_size_ = 0;
  master_ = NULL;
  slave_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

cluster::~cluster() {
  SharedDtor();
}

void cluster::SharedDtor() {
  if (this != default_instance_) {
    delete master_;
    delete slave_;
  }
}

void cluster::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* cluster::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return cluster_descriptor_;
}

const cluster& cluster::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

cluster* cluster::default_instance_ = NULL;

cluster* cluster::New() const {
  return new cluster;
}

void cluster::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (master_ != NULL) master_->::tinytable::master::Clear();
    }
    if (_has_bit(1)) {
      if (slave_ != NULL) slave_->::tinytable::slave::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool cluster::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tinytable.master master = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_master()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slave;
        break;
      }
      
      // required .tinytable.slave slave = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void cluster::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .tinytable.master master = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->master(), output);
  }
  
  // required .tinytable.slave slave = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slave(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* cluster::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .tinytable.master master = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->master(), target);
  }
  
  // required .tinytable.slave slave = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slave(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int cluster::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tinytable.master master = 1;
    if (has_master()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->master());
    }
    
    // required .tinytable.slave slave = 2;
    if (has_slave()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void cluster::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const cluster* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const cluster*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void cluster::MergeFrom(const cluster& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_master()->::tinytable::master::MergeFrom(from.master());
    }
    if (from._has_bit(1)) {
      mutable_slave()->::tinytable::slave::MergeFrom(from.slave());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void cluster::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void cluster::CopyFrom(const cluster& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool cluster::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_master()) {
    if (!this->master().IsInitialized()) return false;
  }
  if (has_slave()) {
    if (!this->slave().IsInitialized()) return false;
  }
  return true;
}

void cluster::Swap(cluster* other) {
  if (other != this) {
    std::swap(master_, other->master_);
    std::swap(slave_, other->slave_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata cluster::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = cluster_descriptor_;
  metadata.reflection = cluster_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int clusters::kClusterFieldNumber;
#endif  // !_MSC_VER

clusters::clusters()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void clusters::InitAsDefaultInstance() {
}

clusters::clusters(const clusters& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void clusters::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

clusters::~clusters() {
  SharedDtor();
}

void clusters::SharedDtor() {
  if (this != default_instance_) {
  }
}

void clusters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* clusters::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return clusters_descriptor_;
}

const clusters& clusters::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

clusters* clusters::default_instance_ = NULL;

clusters* clusters::New() const {
  return new clusters;
}

void clusters::Clear() {
  cluster_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool clusters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.cluster cluster = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cluster:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cluster()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_cluster;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void clusters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.cluster cluster = 1;
  for (int i = 0; i < this->cluster_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->cluster(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* clusters::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.cluster cluster = 1;
  for (int i = 0; i < this->cluster_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->cluster(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int clusters::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.cluster cluster = 1;
  total_size += 1 * this->cluster_size();
  for (int i = 0; i < this->cluster_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cluster(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void clusters::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const clusters* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const clusters*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void clusters::MergeFrom(const clusters& from) {
  GOOGLE_CHECK_NE(&from, this);
  cluster_.MergeFrom(from.cluster_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void clusters::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void clusters::CopyFrom(const clusters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool clusters::IsInitialized() const {
  
  for (int i = 0; i < cluster_size(); i++) {
    if (!this->cluster(i).IsInitialized()) return false;
  }
  return true;
}

void clusters::Swap(clusters* other) {
  if (other != this) {
    cluster_.Swap(&other->cluster_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata clusters::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = clusters_descriptor_;
  metadata.reflection = clusters_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string sort::_default_type_;
#ifndef _MSC_VER
const int sort::kTypeFieldNumber;
const int sort::kMasterFieldNumber;
const int sort::kSlaveFieldNumber;
#endif  // !_MSC_VER

sort::sort()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void sort::InitAsDefaultInstance() {
  master_ = const_cast< ::tinytable::master*>(&::tinytable::master::default_instance());
  slave_ = const_cast< ::tinytable::slave*>(&::tinytable::slave::default_instance());
}

sort::sort(const sort& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void sort::SharedCtor() {
  _cached_size_ = 0;
  type_ = const_cast< ::std::string*>(&_default_type_);
  master_ = NULL;
  slave_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

sort::~sort() {
  SharedDtor();
}

void sort::SharedDtor() {
  if (type_ != &_default_type_) {
    delete type_;
  }
  if (this != default_instance_) {
    delete master_;
    delete slave_;
  }
}

void sort::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* sort::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return sort_descriptor_;
}

const sort& sort::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

sort* sort::default_instance_ = NULL;

sort* sort::New() const {
  return new sort;
}

void sort::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (type_ != &_default_type_) {
        type_->clear();
      }
    }
    if (_has_bit(1)) {
      if (master_ != NULL) master_->::tinytable::master::Clear();
    }
    if (_has_bit(2)) {
      if (slave_ != NULL) slave_->::tinytable::slave::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool sort::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_master;
        break;
      }
      
      // optional .tinytable.master master = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_master:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_master()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_slave;
        break;
      }
      
      // optional .tinytable.slave slave = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void sort::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string type = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->type(), output);
  }
  
  // optional .tinytable.master master = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->master(), output);
  }
  
  // optional .tinytable.slave slave = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->slave(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* sort::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string type = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->type(), target);
  }
  
  // optional .tinytable.master master = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->master(), target);
  }
  
  // optional .tinytable.slave slave = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->slave(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int sort::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }
    
    // optional .tinytable.master master = 2;
    if (has_master()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->master());
    }
    
    // optional .tinytable.slave slave = 3;
    if (has_slave()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void sort::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const sort* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const sort*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void sort::MergeFrom(const sort& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_type(from.type());
    }
    if (from._has_bit(1)) {
      mutable_master()->::tinytable::master::MergeFrom(from.master());
    }
    if (from._has_bit(2)) {
      mutable_slave()->::tinytable::slave::MergeFrom(from.slave());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void sort::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void sort::CopyFrom(const sort& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool sort::IsInitialized() const {
  
  if (has_master()) {
    if (!this->master().IsInitialized()) return false;
  }
  if (has_slave()) {
    if (!this->slave().IsInitialized()) return false;
  }
  return true;
}

void sort::Swap(sort* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(master_, other->master_);
    std::swap(slave_, other->slave_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata sort::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = sort_descriptor_;
  metadata.reflection = sort_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int sorts::kSortFieldNumber;
#endif  // !_MSC_VER

sorts::sorts()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void sorts::InitAsDefaultInstance() {
}

sorts::sorts(const sorts& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void sorts::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

sorts::~sorts() {
  SharedDtor();
}

void sorts::SharedDtor() {
  if (this != default_instance_) {
  }
}

void sorts::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* sorts::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return sorts_descriptor_;
}

const sorts& sorts::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

sorts* sorts::default_instance_ = NULL;

sorts* sorts::New() const {
  return new sorts;
}

void sorts::Clear() {
  sort_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool sorts::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.sort sort = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sort:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sort()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_sort;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void sorts::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.sort sort = 1;
  for (int i = 0; i < this->sort_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sort(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* sorts::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.sort sort = 1;
  for (int i = 0; i < this->sort_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sort(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int sorts::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.sort sort = 1;
  total_size += 1 * this->sort_size();
  for (int i = 0; i < this->sort_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sort(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void sorts::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const sorts* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const sorts*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void sorts::MergeFrom(const sorts& from) {
  GOOGLE_CHECK_NE(&from, this);
  sort_.MergeFrom(from.sort_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void sorts::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void sorts::CopyFrom(const sorts& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool sorts::IsInitialized() const {
  
  for (int i = 0; i < sort_size(); i++) {
    if (!this->sort(i).IsInitialized()) return false;
  }
  return true;
}

void sorts::Swap(sorts* other) {
  if (other != this) {
    sort_.Swap(&other->sort_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata sorts::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = sorts_descriptor_;
  metadata.reflection = sorts_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string queue::_default_type_;
#ifndef _MSC_VER
const int queue::kTypeFieldNumber;
const int queue::kMaxSizeFieldNumber;
const int queue::kMasterFieldNumber;
const int queue::kSlaveFieldNumber;
#endif  // !_MSC_VER

queue::queue()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void queue::InitAsDefaultInstance() {
  master_ = const_cast< ::tinytable::master*>(&::tinytable::master::default_instance());
  slave_ = const_cast< ::tinytable::slave*>(&::tinytable::slave::default_instance());
}

queue::queue(const queue& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void queue::SharedCtor() {
  _cached_size_ = 0;
  type_ = const_cast< ::std::string*>(&_default_type_);
  max_size_ = 0;
  master_ = NULL;
  slave_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

queue::~queue() {
  SharedDtor();
}

void queue::SharedDtor() {
  if (type_ != &_default_type_) {
    delete type_;
  }
  if (this != default_instance_) {
    delete master_;
    delete slave_;
  }
}

void queue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* queue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return queue_descriptor_;
}

const queue& queue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

queue* queue::default_instance_ = NULL;

queue* queue::New() const {
  return new queue;
}

void queue::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (type_ != &_default_type_) {
        type_->clear();
      }
    }
    max_size_ = 0;
    if (_has_bit(2)) {
      if (master_ != NULL) master_->::tinytable::master::Clear();
    }
    if (_has_bit(3)) {
      if (slave_ != NULL) slave_->::tinytable::slave::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool queue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_max_size;
        break;
      }
      
      // optional int32 max_size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_size_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_master;
        break;
      }
      
      // optional .tinytable.master master = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_master:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_master()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_slave;
        break;
      }
      
      // optional .tinytable.slave slave = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void queue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string type = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->type(), output);
  }
  
  // optional int32 max_size = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_size(), output);
  }
  
  // optional .tinytable.master master = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->master(), output);
  }
  
  // optional .tinytable.slave slave = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->slave(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* queue::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string type = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->type(), target);
  }
  
  // optional int32 max_size = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->max_size(), target);
  }
  
  // optional .tinytable.master master = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->master(), target);
  }
  
  // optional .tinytable.slave slave = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->slave(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int queue::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }
    
    // optional int32 max_size = 2;
    if (has_max_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_size());
    }
    
    // optional .tinytable.master master = 3;
    if (has_master()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->master());
    }
    
    // optional .tinytable.slave slave = 4;
    if (has_slave()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void queue::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const queue* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const queue*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void queue::MergeFrom(const queue& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_type(from.type());
    }
    if (from._has_bit(1)) {
      set_max_size(from.max_size());
    }
    if (from._has_bit(2)) {
      mutable_master()->::tinytable::master::MergeFrom(from.master());
    }
    if (from._has_bit(3)) {
      mutable_slave()->::tinytable::slave::MergeFrom(from.slave());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void queue::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void queue::CopyFrom(const queue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool queue::IsInitialized() const {
  
  if (has_master()) {
    if (!this->master().IsInitialized()) return false;
  }
  if (has_slave()) {
    if (!this->slave().IsInitialized()) return false;
  }
  return true;
}

void queue::Swap(queue* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(max_size_, other->max_size_);
    std::swap(master_, other->master_);
    std::swap(slave_, other->slave_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata queue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = queue_descriptor_;
  metadata.reflection = queue_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int queues::kQueueFieldNumber;
#endif  // !_MSC_VER

queues::queues()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void queues::InitAsDefaultInstance() {
}

queues::queues(const queues& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void queues::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

queues::~queues() {
  SharedDtor();
}

void queues::SharedDtor() {
  if (this != default_instance_) {
  }
}

void queues::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* queues::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return queues_descriptor_;
}

const queues& queues::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

queues* queues::default_instance_ = NULL;

queues* queues::New() const {
  return new queues;
}

void queues::Clear() {
  queue_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool queues::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.queue queue = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_queue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_queue()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_queue;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void queues::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.queue queue = 1;
  for (int i = 0; i < this->queue_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->queue(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* queues::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.queue queue = 1;
  for (int i = 0; i < this->queue_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->queue(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int queues::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.queue queue = 1;
  total_size += 1 * this->queue_size();
  for (int i = 0; i < this->queue_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->queue(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void queues::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const queues* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const queues*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void queues::MergeFrom(const queues& from) {
  GOOGLE_CHECK_NE(&from, this);
  queue_.MergeFrom(from.queue_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void queues::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void queues::CopyFrom(const queues& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool queues::IsInitialized() const {
  
  for (int i = 0; i < queue_size(); i++) {
    if (!this->queue(i).IsInitialized()) return false;
  }
  return true;
}

void queues::Swap(queues* other) {
  if (other != this) {
    queue_.Swap(&other->queue_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata queues::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = queues_descriptor_;
  metadata.reflection = queues_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string condition::_default_desc_;
#ifndef _MSC_VER
const int condition::kIntervalSFieldNumber;
const int condition::kIntervalMsFieldNumber;
const int condition::kWeekdayFieldNumber;
const int condition::kHourFieldNumber;
const int condition::kMinuteFieldNumber;
const int condition::kSecondFieldNumber;
const int condition::kDescFieldNumber;
#endif  // !_MSC_VER

condition::condition()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void condition::InitAsDefaultInstance() {
}

condition::condition(const condition& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void condition::SharedCtor() {
  _cached_size_ = 0;
  interval_s_ = 0;
  interval_ms_ = 0;
  weekday_ = 0;
  hour_ = 0;
  minute_ = 0;
  second_ = 0;
  desc_ = const_cast< ::std::string*>(&_default_desc_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

condition::~condition() {
  SharedDtor();
}

void condition::SharedDtor() {
  if (desc_ != &_default_desc_) {
    delete desc_;
  }
  if (this != default_instance_) {
  }
}

void condition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* condition::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return condition_descriptor_;
}

const condition& condition::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

condition* condition::default_instance_ = NULL;

condition* condition::New() const {
  return new condition;
}

void condition::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    interval_s_ = 0;
    interval_ms_ = 0;
    weekday_ = 0;
    hour_ = 0;
    minute_ = 0;
    second_ = 0;
    if (_has_bit(6)) {
      if (desc_ != &_default_desc_) {
        desc_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool condition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 interval_s = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interval_s_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_interval_ms;
        break;
      }
      
      // optional int32 interval_ms = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_interval_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interval_ms_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_weekday;
        break;
      }
      
      // optional int32 weekday = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weekday:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &weekday_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_hour;
        break;
      }
      
      // optional int32 hour = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hour:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hour_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_minute;
        break;
      }
      
      // optional int32 minute = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minute:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minute_)));
          _set_bit(4);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_second;
        break;
      }
      
      // optional int32 second = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_second:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &second_)));
          _set_bit(5);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_desc;
        break;
      }
      
      // optional string desc = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->desc().data(), this->desc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void condition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 interval_s = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->interval_s(), output);
  }
  
  // optional int32 interval_ms = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->interval_ms(), output);
  }
  
  // optional int32 weekday = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->weekday(), output);
  }
  
  // optional int32 hour = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->hour(), output);
  }
  
  // optional int32 minute = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->minute(), output);
  }
  
  // optional int32 second = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->second(), output);
  }
  
  // optional string desc = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->desc(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* condition::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 interval_s = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->interval_s(), target);
  }
  
  // optional int32 interval_ms = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->interval_ms(), target);
  }
  
  // optional int32 weekday = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->weekday(), target);
  }
  
  // optional int32 hour = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->hour(), target);
  }
  
  // optional int32 minute = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->minute(), target);
  }
  
  // optional int32 second = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->second(), target);
  }
  
  // optional string desc = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->desc(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int condition::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 interval_s = 1;
    if (has_interval_s()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interval_s());
    }
    
    // optional int32 interval_ms = 2;
    if (has_interval_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interval_ms());
    }
    
    // optional int32 weekday = 3;
    if (has_weekday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->weekday());
    }
    
    // optional int32 hour = 4;
    if (has_hour()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->hour());
    }
    
    // optional int32 minute = 5;
    if (has_minute()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->minute());
    }
    
    // optional int32 second = 6;
    if (has_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->second());
    }
    
    // optional string desc = 7;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void condition::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const condition* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const condition*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void condition::MergeFrom(const condition& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_interval_s(from.interval_s());
    }
    if (from._has_bit(1)) {
      set_interval_ms(from.interval_ms());
    }
    if (from._has_bit(2)) {
      set_weekday(from.weekday());
    }
    if (from._has_bit(3)) {
      set_hour(from.hour());
    }
    if (from._has_bit(4)) {
      set_minute(from.minute());
    }
    if (from._has_bit(5)) {
      set_second(from.second());
    }
    if (from._has_bit(6)) {
      set_desc(from.desc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void condition::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void condition::CopyFrom(const condition& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool condition::IsInitialized() const {
  
  return true;
}

void condition::Swap(condition* other) {
  if (other != this) {
    std::swap(interval_s_, other->interval_s_);
    std::swap(interval_ms_, other->interval_ms_);
    std::swap(weekday_, other->weekday_);
    std::swap(hour_, other->hour_);
    std::swap(minute_, other->minute_);
    std::swap(second_, other->second_);
    std::swap(desc_, other->desc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata condition::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = condition_descriptor_;
  metadata.reflection = condition_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string colfunc::_default_name_;
const ::std::string colfunc::_default_ops_type_;
const ::std::string colfunc::_default_value_;
const ::std::string colfunc::_default_desc_;
const ::std::string colfunc::_default_min_;
const ::std::string colfunc::_default_max_;
#ifndef _MSC_VER
const int colfunc::kNameFieldNumber;
const int colfunc::kOpsTypeFieldNumber;
const int colfunc::kValueFieldNumber;
const int colfunc::kDescFieldNumber;
const int colfunc::kMinFieldNumber;
const int colfunc::kMaxFieldNumber;
#endif  // !_MSC_VER

colfunc::colfunc()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void colfunc::InitAsDefaultInstance() {
}

colfunc::colfunc(const colfunc& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void colfunc::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  ops_type_ = const_cast< ::std::string*>(&_default_ops_type_);
  value_ = const_cast< ::std::string*>(&_default_value_);
  desc_ = const_cast< ::std::string*>(&_default_desc_);
  min_ = const_cast< ::std::string*>(&_default_min_);
  max_ = const_cast< ::std::string*>(&_default_max_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

colfunc::~colfunc() {
  SharedDtor();
}

void colfunc::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (ops_type_ != &_default_ops_type_) {
    delete ops_type_;
  }
  if (value_ != &_default_value_) {
    delete value_;
  }
  if (desc_ != &_default_desc_) {
    delete desc_;
  }
  if (min_ != &_default_min_) {
    delete min_;
  }
  if (max_ != &_default_max_) {
    delete max_;
  }
  if (this != default_instance_) {
  }
}

void colfunc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* colfunc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return colfunc_descriptor_;
}

const colfunc& colfunc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

colfunc* colfunc::default_instance_ = NULL;

colfunc* colfunc::New() const {
  return new colfunc;
}

void colfunc::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (ops_type_ != &_default_ops_type_) {
        ops_type_->clear();
      }
    }
    if (_has_bit(2)) {
      if (value_ != &_default_value_) {
        value_->clear();
      }
    }
    if (_has_bit(3)) {
      if (desc_ != &_default_desc_) {
        desc_->clear();
      }
    }
    if (_has_bit(4)) {
      if (min_ != &_default_min_) {
        min_->clear();
      }
    }
    if (_has_bit(5)) {
      if (max_ != &_default_max_) {
        max_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool colfunc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ops_type;
        break;
      }
      
      // required string ops_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ops_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ops_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ops_type().data(), this->ops_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }
      
      // optional string value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_desc;
        break;
      }
      
      // optional string desc = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->desc().data(), this->desc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_min;
        break;
      }
      
      // optional string min = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_min:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_min()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->min().data(), this->min().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_max;
        break;
      }
      
      // optional string max = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_max:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_max()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->max().data(), this->max().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void colfunc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required string ops_type = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ops_type().data(), this->ops_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->ops_type(), output);
  }
  
  // optional string value = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->value(), output);
  }
  
  // optional string desc = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->desc(), output);
  }
  
  // optional string min = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->min().data(), this->min().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->min(), output);
  }
  
  // optional string max = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->max().data(), this->max().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->max(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* colfunc::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required string ops_type = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ops_type().data(), this->ops_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ops_type(), target);
  }
  
  // optional string value = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->value(), target);
  }
  
  // optional string desc = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->desc(), target);
  }
  
  // optional string min = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->min().data(), this->min().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->min(), target);
  }
  
  // optional string max = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->max().data(), this->max().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->max(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int colfunc::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required string ops_type = 2;
    if (has_ops_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ops_type());
    }
    
    // optional string value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }
    
    // optional string desc = 4;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }
    
    // optional string min = 5;
    if (has_min()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->min());
    }
    
    // optional string max = 6;
    if (has_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->max());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void colfunc::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const colfunc* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const colfunc*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void colfunc::MergeFrom(const colfunc& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
    if (from._has_bit(1)) {
      set_ops_type(from.ops_type());
    }
    if (from._has_bit(2)) {
      set_value(from.value());
    }
    if (from._has_bit(3)) {
      set_desc(from.desc());
    }
    if (from._has_bit(4)) {
      set_min(from.min());
    }
    if (from._has_bit(5)) {
      set_max(from.max());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void colfunc::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void colfunc::CopyFrom(const colfunc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool colfunc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  
  return true;
}

void colfunc::Swap(colfunc* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(ops_type_, other->ops_type_);
    std::swap(value_, other->value_);
    std::swap(desc_, other->desc_);
    std::swap(min_, other->min_);
    std::swap(max_, other->max_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata colfunc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = colfunc_descriptor_;
  metadata.reflection = colfunc_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int func::kColfuncFieldNumber;
#endif  // !_MSC_VER

func::func()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void func::InitAsDefaultInstance() {
}

func::func(const func& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void func::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

func::~func() {
  SharedDtor();
}

void func::SharedDtor() {
  if (this != default_instance_) {
  }
}

void func::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* func::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return func_descriptor_;
}

const func& func::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

func* func::default_instance_ = NULL;

func* func::New() const {
  return new func;
}

void func::Clear() {
  colfunc_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool func::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.colfunc colfunc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_colfunc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_colfunc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_colfunc;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void func::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.colfunc colfunc = 1;
  for (int i = 0; i < this->colfunc_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->colfunc(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* func::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.colfunc colfunc = 1;
  for (int i = 0; i < this->colfunc_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->colfunc(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int func::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.colfunc colfunc = 1;
  total_size += 1 * this->colfunc_size();
  for (int i = 0; i < this->colfunc_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->colfunc(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void func::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const func* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const func*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void func::MergeFrom(const func& from) {
  GOOGLE_CHECK_NE(&from, this);
  colfunc_.MergeFrom(from.colfunc_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void func::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void func::CopyFrom(const func& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool func::IsInitialized() const {
  
  for (int i = 0; i < colfunc_size(); i++) {
    if (!this->colfunc(i).IsInitialized()) return false;
  }
  return true;
}

void func::Swap(func* other) {
  if (other != this) {
    colfunc_.Swap(&other->colfunc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata func::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = func_descriptor_;
  metadata.reflection = func_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string timertrigger::_default_name_;
const ::std::string timertrigger::_default_desc_;
const ::std::string timertrigger::_default_type_;
const ::std::string timertrigger::_default_timecol_;
#ifndef _MSC_VER
const int timertrigger::kNameFieldNumber;
const int timertrigger::kDescFieldNumber;
const int timertrigger::kTypeFieldNumber;
const int timertrigger::kTimecolFieldNumber;
const int timertrigger::kConditionFieldNumber;
const int timertrigger::kFuncFieldNumber;
#endif  // !_MSC_VER

timertrigger::timertrigger()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void timertrigger::InitAsDefaultInstance() {
  condition_ = const_cast< ::tinytable::condition*>(&::tinytable::condition::default_instance());
  func_ = const_cast< ::tinytable::func*>(&::tinytable::func::default_instance());
}

timertrigger::timertrigger(const timertrigger& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void timertrigger::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  desc_ = const_cast< ::std::string*>(&_default_desc_);
  type_ = const_cast< ::std::string*>(&_default_type_);
  timecol_ = const_cast< ::std::string*>(&_default_timecol_);
  condition_ = NULL;
  func_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

timertrigger::~timertrigger() {
  SharedDtor();
}

void timertrigger::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (desc_ != &_default_desc_) {
    delete desc_;
  }
  if (type_ != &_default_type_) {
    delete type_;
  }
  if (timecol_ != &_default_timecol_) {
    delete timecol_;
  }
  if (this != default_instance_) {
    delete condition_;
    delete func_;
  }
}

void timertrigger::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* timertrigger::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return timertrigger_descriptor_;
}

const timertrigger& timertrigger::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

timertrigger* timertrigger::default_instance_ = NULL;

timertrigger* timertrigger::New() const {
  return new timertrigger;
}

void timertrigger::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (desc_ != &_default_desc_) {
        desc_->clear();
      }
    }
    if (_has_bit(2)) {
      if (type_ != &_default_type_) {
        type_->clear();
      }
    }
    if (_has_bit(3)) {
      if (timecol_ != &_default_timecol_) {
        timecol_->clear();
      }
    }
    if (_has_bit(4)) {
      if (condition_ != NULL) condition_->::tinytable::condition::Clear();
    }
    if (_has_bit(5)) {
      if (func_ != NULL) func_->::tinytable::func::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool timertrigger::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_desc;
        break;
      }
      
      // optional string desc = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->desc().data(), this->desc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_type;
        break;
      }
      
      // required string type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_timecol;
        break;
      }
      
      // required string timecol = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_timecol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_timecol()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->timecol().data(), this->timecol().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_condition;
        break;
      }
      
      // required .tinytable.condition condition = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_condition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_condition()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_func;
        break;
      }
      
      // required .tinytable.func func = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_func:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_func()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void timertrigger::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional string desc = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->desc(), output);
  }
  
  // required string type = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->type(), output);
  }
  
  // required string timecol = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->timecol().data(), this->timecol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->timecol(), output);
  }
  
  // required .tinytable.condition condition = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->condition(), output);
  }
  
  // required .tinytable.func func = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->func(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* timertrigger::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional string desc = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->desc(), target);
  }
  
  // required string type = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->type(), target);
  }
  
  // required string timecol = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->timecol().data(), this->timecol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->timecol(), target);
  }
  
  // required .tinytable.condition condition = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->condition(), target);
  }
  
  // required .tinytable.func func = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->func(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int timertrigger::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string desc = 2;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }
    
    // required string type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }
    
    // required string timecol = 4;
    if (has_timecol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->timecol());
    }
    
    // required .tinytable.condition condition = 5;
    if (has_condition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->condition());
    }
    
    // required .tinytable.func func = 6;
    if (has_func()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->func());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void timertrigger::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const timertrigger* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const timertrigger*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void timertrigger::MergeFrom(const timertrigger& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
    if (from._has_bit(1)) {
      set_desc(from.desc());
    }
    if (from._has_bit(2)) {
      set_type(from.type());
    }
    if (from._has_bit(3)) {
      set_timecol(from.timecol());
    }
    if (from._has_bit(4)) {
      mutable_condition()->::tinytable::condition::MergeFrom(from.condition());
    }
    if (from._has_bit(5)) {
      mutable_func()->::tinytable::func::MergeFrom(from.func());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void timertrigger::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void timertrigger::CopyFrom(const timertrigger& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool timertrigger::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003c) != 0x0000003c) return false;
  
  if (has_func()) {
    if (!this->func().IsInitialized()) return false;
  }
  return true;
}

void timertrigger::Swap(timertrigger* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(desc_, other->desc_);
    std::swap(type_, other->type_);
    std::swap(timecol_, other->timecol_);
    std::swap(condition_, other->condition_);
    std::swap(func_, other->func_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata timertrigger::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = timertrigger_descriptor_;
  metadata.reflection = timertrigger_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int timertriggers::kTimertriggerFieldNumber;
#endif  // !_MSC_VER

timertriggers::timertriggers()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void timertriggers::InitAsDefaultInstance() {
}

timertriggers::timertriggers(const timertriggers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void timertriggers::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

timertriggers::~timertriggers() {
  SharedDtor();
}

void timertriggers::SharedDtor() {
  if (this != default_instance_) {
  }
}

void timertriggers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* timertriggers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return timertriggers_descriptor_;
}

const timertriggers& timertriggers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

timertriggers* timertriggers::default_instance_ = NULL;

timertriggers* timertriggers::New() const {
  return new timertriggers;
}

void timertriggers::Clear() {
  timertrigger_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool timertriggers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.timertrigger timertrigger = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_timertrigger:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_timertrigger()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_timertrigger;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void timertriggers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.timertrigger timertrigger = 1;
  for (int i = 0; i < this->timertrigger_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->timertrigger(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* timertriggers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.timertrigger timertrigger = 1;
  for (int i = 0; i < this->timertrigger_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->timertrigger(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int timertriggers::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.timertrigger timertrigger = 1;
  total_size += 1 * this->timertrigger_size();
  for (int i = 0; i < this->timertrigger_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->timertrigger(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void timertriggers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const timertriggers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const timertriggers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void timertriggers::MergeFrom(const timertriggers& from) {
  GOOGLE_CHECK_NE(&from, this);
  timertrigger_.MergeFrom(from.timertrigger_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void timertriggers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void timertriggers::CopyFrom(const timertriggers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool timertriggers::IsInitialized() const {
  
  for (int i = 0; i < timertrigger_size(); i++) {
    if (!this->timertrigger(i).IsInitialized()) return false;
  }
  return true;
}

void timertriggers::Swap(timertriggers* other) {
  if (other != this) {
    timertrigger_.Swap(&other->timertrigger_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata timertriggers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = timertriggers_descriptor_;
  metadata.reflection = timertriggers_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int triggers::kTimertriggersFieldNumber;
#endif  // !_MSC_VER

triggers::triggers()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void triggers::InitAsDefaultInstance() {
  timertriggers_ = const_cast< ::tinytable::timertriggers*>(&::tinytable::timertriggers::default_instance());
}

triggers::triggers(const triggers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void triggers::SharedCtor() {
  _cached_size_ = 0;
  timertriggers_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

triggers::~triggers() {
  SharedDtor();
}

void triggers::SharedDtor() {
  if (this != default_instance_) {
    delete timertriggers_;
  }
}

void triggers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* triggers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return triggers_descriptor_;
}

const triggers& triggers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

triggers* triggers::default_instance_ = NULL;

triggers* triggers::New() const {
  return new triggers;
}

void triggers::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (timertriggers_ != NULL) timertriggers_->::tinytable::timertriggers::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool triggers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .tinytable.timertriggers timertriggers = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timertriggers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void triggers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .tinytable.timertriggers timertriggers = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->timertriggers(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* triggers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .tinytable.timertriggers timertriggers = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->timertriggers(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int triggers::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .tinytable.timertriggers timertriggers = 1;
    if (has_timertriggers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->timertriggers());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void triggers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const triggers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const triggers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void triggers::MergeFrom(const triggers& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_timertriggers()->::tinytable::timertriggers::MergeFrom(from.timertriggers());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void triggers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void triggers::CopyFrom(const triggers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool triggers::IsInitialized() const {
  
  if (has_timertriggers()) {
    if (!this->timertriggers().IsInitialized()) return false;
  }
  return true;
}

void triggers::Swap(triggers* other) {
  if (other != this) {
    std::swap(timertriggers_, other->timertriggers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata triggers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = triggers_descriptor_;
  metadata.reflection = triggers_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string tinytable::_default_name_;
const ::std::string tinytable::_default_desc_;
const ::std::string tinytable::_default_servercol_;
const ::std::string tinytable::_default_loadtype_;
const ::std::string tinytable::_default_type_;
const ::std::string tinytable::_default_firstsource_;
const ::std::string tinytable::_default_updatetype_;
#ifndef _MSC_VER
const int tinytable::kNameFieldNumber;
const int tinytable::kDescFieldNumber;
const int tinytable::kServercolFieldNumber;
const int tinytable::kExpiredFieldNumber;
const int tinytable::kLoadtypeFieldNumber;
const int tinytable::kTypeFieldNumber;
const int tinytable::kFirstsourceFieldNumber;
const int tinytable::kUpdatetypeFieldNumber;
const int tinytable::kColumnsFieldNumber;
const int tinytable::kUniquesFieldNumber;
const int tinytable::kClustersFieldNumber;
const int tinytable::kSortsFieldNumber;
const int tinytable::kTriggersFieldNumber;
const int tinytable::kQueuesFieldNumber;
#endif  // !_MSC_VER

tinytable::tinytable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void tinytable::InitAsDefaultInstance() {
  columns_ = const_cast< ::tinytable::columns*>(&::tinytable::columns::default_instance());
  uniques_ = const_cast< ::tinytable::uniques*>(&::tinytable::uniques::default_instance());
  clusters_ = const_cast< ::tinytable::clusters*>(&::tinytable::clusters::default_instance());
  sorts_ = const_cast< ::tinytable::sorts*>(&::tinytable::sorts::default_instance());
  triggers_ = const_cast< ::tinytable::triggers*>(&::tinytable::triggers::default_instance());
  queues_ = const_cast< ::tinytable::queues*>(&::tinytable::queues::default_instance());
}

tinytable::tinytable(const tinytable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void tinytable::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  desc_ = const_cast< ::std::string*>(&_default_desc_);
  servercol_ = const_cast< ::std::string*>(&_default_servercol_);
  expired_ = 0;
  loadtype_ = const_cast< ::std::string*>(&_default_loadtype_);
  type_ = const_cast< ::std::string*>(&_default_type_);
  firstsource_ = const_cast< ::std::string*>(&_default_firstsource_);
  updatetype_ = const_cast< ::std::string*>(&_default_updatetype_);
  columns_ = NULL;
  uniques_ = NULL;
  clusters_ = NULL;
  sorts_ = NULL;
  triggers_ = NULL;
  queues_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tinytable::~tinytable() {
  SharedDtor();
}

void tinytable::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (desc_ != &_default_desc_) {
    delete desc_;
  }
  if (servercol_ != &_default_servercol_) {
    delete servercol_;
  }
  if (loadtype_ != &_default_loadtype_) {
    delete loadtype_;
  }
  if (type_ != &_default_type_) {
    delete type_;
  }
  if (firstsource_ != &_default_firstsource_) {
    delete firstsource_;
  }
  if (updatetype_ != &_default_updatetype_) {
    delete updatetype_;
  }
  if (this != default_instance_) {
    delete columns_;
    delete uniques_;
    delete clusters_;
    delete sorts_;
    delete triggers_;
    delete queues_;
  }
}

void tinytable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* tinytable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return tinytable_descriptor_;
}

const tinytable& tinytable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

tinytable* tinytable::default_instance_ = NULL;

tinytable* tinytable::New() const {
  return new tinytable;
}

void tinytable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (desc_ != &_default_desc_) {
        desc_->clear();
      }
    }
    if (_has_bit(2)) {
      if (servercol_ != &_default_servercol_) {
        servercol_->clear();
      }
    }
    expired_ = 0;
    if (_has_bit(4)) {
      if (loadtype_ != &_default_loadtype_) {
        loadtype_->clear();
      }
    }
    if (_has_bit(5)) {
      if (type_ != &_default_type_) {
        type_->clear();
      }
    }
    if (_has_bit(6)) {
      if (firstsource_ != &_default_firstsource_) {
        firstsource_->clear();
      }
    }
    if (_has_bit(7)) {
      if (updatetype_ != &_default_updatetype_) {
        updatetype_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (_has_bit(8)) {
      if (columns_ != NULL) columns_->::tinytable::columns::Clear();
    }
    if (_has_bit(9)) {
      if (uniques_ != NULL) uniques_->::tinytable::uniques::Clear();
    }
    if (_has_bit(10)) {
      if (clusters_ != NULL) clusters_->::tinytable::clusters::Clear();
    }
    if (_has_bit(11)) {
      if (sorts_ != NULL) sorts_->::tinytable::sorts::Clear();
    }
    if (_has_bit(12)) {
      if (triggers_ != NULL) triggers_->::tinytable::triggers::Clear();
    }
    if (_has_bit(13)) {
      if (queues_ != NULL) queues_->::tinytable::queues::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool tinytable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_desc;
        break;
      }
      
      // optional string desc = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->desc().data(), this->desc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_servercol;
        break;
      }
      
      // optional string servercol = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_servercol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_servercol()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->servercol().data(), this->servercol().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_expired;
        break;
      }
      
      // required int32 expired = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_expired:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &expired_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_loadtype;
        break;
      }
      
      // optional string loadtype = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_loadtype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_loadtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->loadtype().data(), this->loadtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_type;
        break;
      }
      
      // optional string type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_firstsource;
        break;
      }
      
      // optional string firstsource = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_firstsource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_firstsource()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->firstsource().data(), this->firstsource().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_updatetype;
        break;
      }
      
      // optional string updatetype = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_updatetype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_updatetype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->updatetype().data(), this->updatetype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_columns;
        break;
      }
      
      // optional .tinytable.columns columns = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_columns:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_columns()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_uniques;
        break;
      }
      
      // optional .tinytable.uniques uniques = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_uniques:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_uniques()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_clusters;
        break;
      }
      
      // optional .tinytable.clusters clusters = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clusters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_clusters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_sorts;
        break;
      }
      
      // optional .tinytable.sorts sorts = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sorts:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sorts()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_triggers;
        break;
      }
      
      // optional .tinytable.triggers triggers = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_triggers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_triggers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_queues;
        break;
      }
      
      // optional .tinytable.queues queues = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_queues:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_queues()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void tinytable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional string desc = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->desc(), output);
  }
  
  // optional string servercol = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->servercol().data(), this->servercol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->servercol(), output);
  }
  
  // required int32 expired = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->expired(), output);
  }
  
  // optional string loadtype = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->loadtype().data(), this->loadtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->loadtype(), output);
  }
  
  // optional string type = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->type(), output);
  }
  
  // optional string firstsource = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->firstsource().data(), this->firstsource().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->firstsource(), output);
  }
  
  // optional string updatetype = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->updatetype().data(), this->updatetype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->updatetype(), output);
  }
  
  // optional .tinytable.columns columns = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->columns(), output);
  }
  
  // optional .tinytable.uniques uniques = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->uniques(), output);
  }
  
  // optional .tinytable.clusters clusters = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->clusters(), output);
  }
  
  // optional .tinytable.sorts sorts = 12;
  if (_has_bit(11)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->sorts(), output);
  }
  
  // optional .tinytable.triggers triggers = 13;
  if (_has_bit(12)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->triggers(), output);
  }
  
  // optional .tinytable.queues queues = 14;
  if (_has_bit(13)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->queues(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* tinytable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional string desc = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->desc(), target);
  }
  
  // optional string servercol = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->servercol().data(), this->servercol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->servercol(), target);
  }
  
  // required int32 expired = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->expired(), target);
  }
  
  // optional string loadtype = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->loadtype().data(), this->loadtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->loadtype(), target);
  }
  
  // optional string type = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->type(), target);
  }
  
  // optional string firstsource = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->firstsource().data(), this->firstsource().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->firstsource(), target);
  }
  
  // optional string updatetype = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->updatetype().data(), this->updatetype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->updatetype(), target);
  }
  
  // optional .tinytable.columns columns = 9;
  if (_has_bit(8)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->columns(), target);
  }
  
  // optional .tinytable.uniques uniques = 10;
  if (_has_bit(9)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->uniques(), target);
  }
  
  // optional .tinytable.clusters clusters = 11;
  if (_has_bit(10)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->clusters(), target);
  }
  
  // optional .tinytable.sorts sorts = 12;
  if (_has_bit(11)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->sorts(), target);
  }
  
  // optional .tinytable.triggers triggers = 13;
  if (_has_bit(12)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->triggers(), target);
  }
  
  // optional .tinytable.queues queues = 14;
  if (_has_bit(13)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->queues(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int tinytable::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string desc = 2;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }
    
    // optional string servercol = 3;
    if (has_servercol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->servercol());
    }
    
    // required int32 expired = 4;
    if (has_expired()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->expired());
    }
    
    // optional string loadtype = 5;
    if (has_loadtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->loadtype());
    }
    
    // optional string type = 6;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }
    
    // optional string firstsource = 7;
    if (has_firstsource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->firstsource());
    }
    
    // optional string updatetype = 8;
    if (has_updatetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->updatetype());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .tinytable.columns columns = 9;
    if (has_columns()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->columns());
    }
    
    // optional .tinytable.uniques uniques = 10;
    if (has_uniques()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->uniques());
    }
    
    // optional .tinytable.clusters clusters = 11;
    if (has_clusters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->clusters());
    }
    
    // optional .tinytable.sorts sorts = 12;
    if (has_sorts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sorts());
    }
    
    // optional .tinytable.triggers triggers = 13;
    if (has_triggers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->triggers());
    }
    
    // optional .tinytable.queues queues = 14;
    if (has_queues()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->queues());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tinytable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const tinytable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const tinytable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void tinytable::MergeFrom(const tinytable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
    if (from._has_bit(1)) {
      set_desc(from.desc());
    }
    if (from._has_bit(2)) {
      set_servercol(from.servercol());
    }
    if (from._has_bit(3)) {
      set_expired(from.expired());
    }
    if (from._has_bit(4)) {
      set_loadtype(from.loadtype());
    }
    if (from._has_bit(5)) {
      set_type(from.type());
    }
    if (from._has_bit(6)) {
      set_firstsource(from.firstsource());
    }
    if (from._has_bit(7)) {
      set_updatetype(from.updatetype());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      mutable_columns()->::tinytable::columns::MergeFrom(from.columns());
    }
    if (from._has_bit(9)) {
      mutable_uniques()->::tinytable::uniques::MergeFrom(from.uniques());
    }
    if (from._has_bit(10)) {
      mutable_clusters()->::tinytable::clusters::MergeFrom(from.clusters());
    }
    if (from._has_bit(11)) {
      mutable_sorts()->::tinytable::sorts::MergeFrom(from.sorts());
    }
    if (from._has_bit(12)) {
      mutable_triggers()->::tinytable::triggers::MergeFrom(from.triggers());
    }
    if (from._has_bit(13)) {
      mutable_queues()->::tinytable::queues::MergeFrom(from.queues());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void tinytable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void tinytable::CopyFrom(const tinytable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tinytable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;
  
  if (has_columns()) {
    if (!this->columns().IsInitialized()) return false;
  }
  if (has_uniques()) {
    if (!this->uniques().IsInitialized()) return false;
  }
  if (has_clusters()) {
    if (!this->clusters().IsInitialized()) return false;
  }
  if (has_sorts()) {
    if (!this->sorts().IsInitialized()) return false;
  }
  if (has_triggers()) {
    if (!this->triggers().IsInitialized()) return false;
  }
  if (has_queues()) {
    if (!this->queues().IsInitialized()) return false;
  }
  return true;
}

void tinytable::Swap(tinytable* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(desc_, other->desc_);
    std::swap(servercol_, other->servercol_);
    std::swap(expired_, other->expired_);
    std::swap(loadtype_, other->loadtype_);
    std::swap(type_, other->type_);
    std::swap(firstsource_, other->firstsource_);
    std::swap(updatetype_, other->updatetype_);
    std::swap(columns_, other->columns_);
    std::swap(uniques_, other->uniques_);
    std::swap(clusters_, other->clusters_);
    std::swap(sorts_, other->sorts_);
    std::swap(triggers_, other->triggers_);
    std::swap(queues_, other->queues_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata tinytable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = tinytable_descriptor_;
  metadata.reflection = tinytable_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string table::_default_name_;
const ::std::string table::_default_update_type_;
#ifndef _MSC_VER
const int table::kNameFieldNumber;
const int table::kUpdateTypeFieldNumber;
const int table::kSaveFieldNumber;
#endif  // !_MSC_VER

table::table()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void table::InitAsDefaultInstance() {
}

table::table(const table& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void table::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  update_type_ = const_cast< ::std::string*>(&_default_update_type_);
  save_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

table::~table() {
  SharedDtor();
}

void table::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (update_type_ != &_default_update_type_) {
    delete update_type_;
  }
  if (this != default_instance_) {
  }
}

void table::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* table::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return table_descriptor_;
}

const table& table::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

table* table::default_instance_ = NULL;

table* table::New() const {
  return new table;
}

void table::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (update_type_ != &_default_update_type_) {
        update_type_->clear();
      }
    }
    save_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool table::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_update_type;
        break;
      }
      
      // optional string update_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_update_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_update_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->update_type().data(), this->update_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_save;
        break;
      }
      
      // optional int32 save = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_save:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &save_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void table::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional string update_type = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->update_type().data(), this->update_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->update_type(), output);
  }
  
  // optional int32 save = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->save(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* table::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional string update_type = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->update_type().data(), this->update_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->update_type(), target);
  }
  
  // optional int32 save = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->save(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int table::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string update_type = 2;
    if (has_update_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->update_type());
    }
    
    // optional int32 save = 3;
    if (has_save()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->save());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void table::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const table* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const table*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void table::MergeFrom(const table& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
    if (from._has_bit(1)) {
      set_update_type(from.update_type());
    }
    if (from._has_bit(2)) {
      set_save(from.save());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void table::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void table::CopyFrom(const table& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool table::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void table::Swap(table* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(update_type_, other->update_type_);
    std::swap(save_, other->save_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata table::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = table_descriptor_;
  metadata.reflection = table_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int tables::kTableFieldNumber;
#endif  // !_MSC_VER

tables::tables()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void tables::InitAsDefaultInstance() {
}

tables::tables(const tables& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void tables::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tables::~tables() {
  SharedDtor();
}

void tables::SharedDtor() {
  if (this != default_instance_) {
  }
}

void tables::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* tables::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return tables_descriptor_;
}

const tables& tables::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

tables* tables::default_instance_ = NULL;

tables* tables::New() const {
  return new tables;
}

void tables::Clear() {
  table_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool tables::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.table table = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_table:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_table()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_table;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void tables::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.table table = 1;
  for (int i = 0; i < this->table_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->table(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* tables::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.table table = 1;
  for (int i = 0; i < this->table_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->table(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int tables::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.table table = 1;
  total_size += 1 * this->table_size();
  for (int i = 0; i < this->table_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->table(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tables::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const tables* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const tables*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void tables::MergeFrom(const tables& from) {
  GOOGLE_CHECK_NE(&from, this);
  table_.MergeFrom(from.table_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void tables::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void tables::CopyFrom(const tables& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tables::IsInitialized() const {
  
  for (int i = 0; i < table_size(); i++) {
    if (!this->table(i).IsInitialized()) return false;
  }
  return true;
}

void tables::Swap(tables* other) {
  if (other != this) {
    table_.Swap(&other->table_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata tables::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = tables_descriptor_;
  metadata.reflection = tables_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string tablecol::_default_name_;
#ifndef _MSC_VER
const int tablecol::kNameFieldNumber;
const int tablecol::kColsFieldNumber;
#endif  // !_MSC_VER

tablecol::tablecol()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void tablecol::InitAsDefaultInstance() {
  cols_ = const_cast< ::tinytable::cols*>(&::tinytable::cols::default_instance());
}

tablecol::tablecol(const tablecol& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void tablecol::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  cols_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tablecol::~tablecol() {
  SharedDtor();
}

void tablecol::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (this != default_instance_) {
    delete cols_;
  }
}

void tablecol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* tablecol::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return tablecol_descriptor_;
}

const tablecol& tablecol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

tablecol* tablecol::default_instance_ = NULL;

tablecol* tablecol::New() const {
  return new tablecol;
}

void tablecol::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (cols_ != NULL) cols_->::tinytable::cols::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool tablecol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cols;
        break;
      }
      
      // required .tinytable.cols cols = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cols:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cols()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void tablecol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required .tinytable.cols cols = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->cols(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* tablecol::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required .tinytable.cols cols = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->cols(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int tablecol::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required .tinytable.cols cols = 2;
    if (has_cols()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cols());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tablecol::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const tablecol* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const tablecol*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void tablecol::MergeFrom(const tablecol& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
    if (from._has_bit(1)) {
      mutable_cols()->::tinytable::cols::MergeFrom(from.cols());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void tablecol::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void tablecol::CopyFrom(const tablecol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tablecol::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_cols()) {
    if (!this->cols().IsInitialized()) return false;
  }
  return true;
}

void tablecol::Swap(tablecol* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(cols_, other->cols_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata tablecol::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = tablecol_descriptor_;
  metadata.reflection = tablecol_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int tablecols::kTablecolFieldNumber;
#endif  // !_MSC_VER

tablecols::tablecols()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void tablecols::InitAsDefaultInstance() {
}

tablecols::tablecols(const tablecols& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void tablecols::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tablecols::~tablecols() {
  SharedDtor();
}

void tablecols::SharedDtor() {
  if (this != default_instance_) {
  }
}

void tablecols::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* tablecols::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return tablecols_descriptor_;
}

const tablecols& tablecols::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

tablecols* tablecols::default_instance_ = NULL;

tablecols* tablecols::New() const {
  return new tablecols;
}

void tablecols::Clear() {
  tablecol_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool tablecols::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.tablecol tablecol = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tablecol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tablecol()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_tablecol;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void tablecols::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.tablecol tablecol = 1;
  for (int i = 0; i < this->tablecol_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->tablecol(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* tablecols::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.tablecol tablecol = 1;
  for (int i = 0; i < this->tablecol_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->tablecol(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int tablecols::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.tablecol tablecol = 1;
  total_size += 1 * this->tablecol_size();
  for (int i = 0; i < this->tablecol_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tablecol(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tablecols::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const tablecols* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const tablecols*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void tablecols::MergeFrom(const tablecols& from) {
  GOOGLE_CHECK_NE(&from, this);
  tablecol_.MergeFrom(from.tablecol_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void tablecols::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void tablecols::CopyFrom(const tablecols& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tablecols::IsInitialized() const {
  
  for (int i = 0; i < tablecol_size(); i++) {
    if (!this->tablecol(i).IsInitialized()) return false;
  }
  return true;
}

void tablecols::Swap(tablecols* other) {
  if (other != this) {
    tablecol_.Swap(&other->tablecol_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata tablecols::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = tablecols_descriptor_;
  metadata.reflection = tablecols_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string expire::_default_name_;
#ifndef _MSC_VER
const int expire::kNameFieldNumber;
const int expire::kTimeoutFieldNumber;
const int expire::kTablecolsFieldNumber;
#endif  // !_MSC_VER

expire::expire()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void expire::InitAsDefaultInstance() {
  tablecols_ = const_cast< ::tinytable::tablecols*>(&::tinytable::tablecols::default_instance());
}

expire::expire(const expire& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void expire::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  timeout_ = 0;
  tablecols_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

expire::~expire() {
  SharedDtor();
}

void expire::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (this != default_instance_) {
    delete tablecols_;
  }
}

void expire::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* expire::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return expire_descriptor_;
}

const expire& expire::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

expire* expire::default_instance_ = NULL;

expire* expire::New() const {
  return new expire;
}

void expire::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    timeout_ = 0;
    if (_has_bit(2)) {
      if (tablecols_ != NULL) tablecols_->::tinytable::tablecols::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool expire::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_timeout;
        break;
      }
      
      // required int32 timeout = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timeout_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tablecols;
        break;
      }
      
      // required .tinytable.tablecols tablecols = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tablecols:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tablecols()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void expire::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required int32 timeout = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->timeout(), output);
  }
  
  // required .tinytable.tablecols tablecols = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tablecols(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* expire::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required int32 timeout = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->timeout(), target);
  }
  
  // required .tinytable.tablecols tablecols = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tablecols(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int expire::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required int32 timeout = 2;
    if (has_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timeout());
    }
    
    // required .tinytable.tablecols tablecols = 3;
    if (has_tablecols()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tablecols());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void expire::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const expire* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const expire*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void expire::MergeFrom(const expire& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
    if (from._has_bit(1)) {
      set_timeout(from.timeout());
    }
    if (from._has_bit(2)) {
      mutable_tablecols()->::tinytable::tablecols::MergeFrom(from.tablecols());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void expire::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void expire::CopyFrom(const expire& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool expire::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_tablecols()) {
    if (!this->tablecols().IsInitialized()) return false;
  }
  return true;
}

void expire::Swap(expire* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(timeout_, other->timeout_);
    std::swap(tablecols_, other->tablecols_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata expire::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = expire_descriptor_;
  metadata.reflection = expire_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int expires::kExpireFieldNumber;
#endif  // !_MSC_VER

expires::expires()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void expires::InitAsDefaultInstance() {
}

expires::expires(const expires& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void expires::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

expires::~expires() {
  SharedDtor();
}

void expires::SharedDtor() {
  if (this != default_instance_) {
  }
}

void expires::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* expires::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return expires_descriptor_;
}

const expires& expires::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tinytable_2eproto();  return *default_instance_;
}

expires* expires::default_instance_ = NULL;

expires* expires::New() const {
  return new expires;
}

void expires::Clear() {
  expire_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool expires::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tinytable.expire expire = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_expire:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_expire()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_expire;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void expires::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .tinytable.expire expire = 1;
  for (int i = 0; i < this->expire_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->expire(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* expires::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .tinytable.expire expire = 1;
  for (int i = 0; i < this->expire_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->expire(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int expires::ByteSize() const {
  int total_size = 0;
  
  // repeated .tinytable.expire expire = 1;
  total_size += 1 * this->expire_size();
  for (int i = 0; i < this->expire_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->expire(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void expires::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const expires* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const expires*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void expires::MergeFrom(const expires& from) {
  GOOGLE_CHECK_NE(&from, this);
  expire_.MergeFrom(from.expire_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void expires::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void expires::CopyFrom(const expires& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool expires::IsInitialized() const {
  
  for (int i = 0; i < expire_size(); i++) {
    if (!this->expire(i).IsInitialized()) return false;
  }
  return true;
}

void expires::Swap(expires* other) {
  if (other != this) {
    expire_.Swap(&other->expire_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata expires::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = expires_descriptor_;
  metadata.reflection = expires_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tinytable

// @@protoc_insertion_point(global_scope)
