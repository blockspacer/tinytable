// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tinytable.proto

#ifndef PROTOBUF_tinytable_2eproto__INCLUDED
#define PROTOBUF_tinytable_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace tinytable {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tinytable_2eproto();
void protobuf_AssignDesc_tinytable_2eproto();
void protobuf_ShutdownFile_tinytable_2eproto();

class columns;
class column;
class col;
class cols;
class uniques;
class unique;
class master;
class slave;
class cluster;
class clusters;
class sort;
class sorts;
class queue;
class queues;
class condition;
class colfunc;
class func;
class timertrigger;
class timertriggers;
class triggers;
class tinytable;
class table;
class tables;
class tablecol;
class tablecols;
class expire;
class expires;

// ===================================================================

class columns : public ::google::protobuf::Message {
 public:
  columns();
  virtual ~columns();
  
  columns(const columns& from);
  
  inline columns& operator=(const columns& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const columns& default_instance();
  
  void Swap(columns* other);
  
  // implements Message ----------------------------------------------
  
  columns* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const columns& from);
  void MergeFrom(const columns& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.column column = 1;
  inline int column_size() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 1;
  inline const ::tinytable::column& column(int index) const;
  inline ::tinytable::column* mutable_column(int index);
  inline ::tinytable::column* add_column();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::column >&
      column() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::column >*
      mutable_column();
  
  // @@protoc_insertion_point(class_scope:tinytable.columns)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::column > column_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static columns* default_instance_;
};
// -------------------------------------------------------------------

class column : public ::google::protobuf::Message {
 public:
  column();
  virtual ~column();
  
  column(const column& from);
  
  inline column& operator=(const column& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const column& default_instance();
  
  void Swap(column* other);
  
  // implements Message ----------------------------------------------
  
  column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const column& from);
  void MergeFrom(const column& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required string datatype = 2;
  inline bool has_datatype() const;
  inline void clear_datatype();
  static const int kDatatypeFieldNumber = 2;
  inline const ::std::string& datatype() const;
  inline void set_datatype(const ::std::string& value);
  inline void set_datatype(const char* value);
  inline void set_datatype(const char* value, size_t size);
  inline ::std::string* mutable_datatype();
  
  // optional int32 maxlen = 3;
  inline bool has_maxlen() const;
  inline void clear_maxlen();
  static const int kMaxlenFieldNumber = 3;
  inline ::google::protobuf::int32 maxlen() const;
  inline void set_maxlen(::google::protobuf::int32 value);
  
  // optional bool is_primary = 4;
  inline bool has_is_primary() const;
  inline void clear_is_primary();
  static const int kIsPrimaryFieldNumber = 4;
  inline bool is_primary() const;
  inline void set_is_primary(bool value);
  
  // optional string desc = 5;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 5;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  
  // optional int32 serial = 6;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 6;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:tinytable.column)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* datatype_;
  static const ::std::string _default_datatype_;
  ::google::protobuf::int32 maxlen_;
  bool is_primary_;
  ::std::string* desc_;
  static const ::std::string _default_desc_;
  ::google::protobuf::int32 serial_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static column* default_instance_;
};
// -------------------------------------------------------------------

class col : public ::google::protobuf::Message {
 public:
  col();
  virtual ~col();
  
  col(const col& from);
  
  inline col& operator=(const col& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const col& default_instance();
  
  void Swap(col* other);
  
  // implements Message ----------------------------------------------
  
  col* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const col& from);
  void MergeFrom(const col& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:tinytable.col)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static col* default_instance_;
};
// -------------------------------------------------------------------

class cols : public ::google::protobuf::Message {
 public:
  cols();
  virtual ~cols();
  
  cols(const cols& from);
  
  inline cols& operator=(const cols& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const cols& default_instance();
  
  void Swap(cols* other);
  
  // implements Message ----------------------------------------------
  
  cols* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cols& from);
  void MergeFrom(const cols& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.col col = 1;
  inline int col_size() const;
  inline void clear_col();
  static const int kColFieldNumber = 1;
  inline const ::tinytable::col& col(int index) const;
  inline ::tinytable::col* mutable_col(int index);
  inline ::tinytable::col* add_col();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::col >&
      col() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::col >*
      mutable_col();
  
  // @@protoc_insertion_point(class_scope:tinytable.cols)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::col > col_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static cols* default_instance_;
};
// -------------------------------------------------------------------

class uniques : public ::google::protobuf::Message {
 public:
  uniques();
  virtual ~uniques();
  
  uniques(const uniques& from);
  
  inline uniques& operator=(const uniques& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const uniques& default_instance();
  
  void Swap(uniques* other);
  
  // implements Message ----------------------------------------------
  
  uniques* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const uniques& from);
  void MergeFrom(const uniques& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.unique unique = 1;
  inline int unique_size() const;
  inline void clear_unique();
  static const int kUniqueFieldNumber = 1;
  inline const ::tinytable::unique& unique(int index) const;
  inline ::tinytable::unique* mutable_unique(int index);
  inline ::tinytable::unique* add_unique();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::unique >&
      unique() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::unique >*
      mutable_unique();
  
  // @@protoc_insertion_point(class_scope:tinytable.uniques)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::unique > unique_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static uniques* default_instance_;
};
// -------------------------------------------------------------------

class unique : public ::google::protobuf::Message {
 public:
  unique();
  virtual ~unique();
  
  unique(const unique& from);
  
  inline unique& operator=(const unique& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const unique& default_instance();
  
  void Swap(unique* other);
  
  // implements Message ----------------------------------------------
  
  unique* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unique& from);
  void MergeFrom(const unique& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.col col = 1;
  inline int col_size() const;
  inline void clear_col();
  static const int kColFieldNumber = 1;
  inline const ::tinytable::col& col(int index) const;
  inline ::tinytable::col* mutable_col(int index);
  inline ::tinytable::col* add_col();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::col >&
      col() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::col >*
      mutable_col();
  
  // @@protoc_insertion_point(class_scope:tinytable.unique)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::col > col_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static unique* default_instance_;
};
// -------------------------------------------------------------------

class master : public ::google::protobuf::Message {
 public:
  master();
  virtual ~master();
  
  master(const master& from);
  
  inline master& operator=(const master& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const master& default_instance();
  
  void Swap(master* other);
  
  // implements Message ----------------------------------------------
  
  master* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const master& from);
  void MergeFrom(const master& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.col col = 1;
  inline int col_size() const;
  inline void clear_col();
  static const int kColFieldNumber = 1;
  inline const ::tinytable::col& col(int index) const;
  inline ::tinytable::col* mutable_col(int index);
  inline ::tinytable::col* add_col();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::col >&
      col() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::col >*
      mutable_col();
  
  // @@protoc_insertion_point(class_scope:tinytable.master)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::col > col_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static master* default_instance_;
};
// -------------------------------------------------------------------

class slave : public ::google::protobuf::Message {
 public:
  slave();
  virtual ~slave();
  
  slave(const slave& from);
  
  inline slave& operator=(const slave& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const slave& default_instance();
  
  void Swap(slave* other);
  
  // implements Message ----------------------------------------------
  
  slave* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const slave& from);
  void MergeFrom(const slave& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.col col = 1;
  inline int col_size() const;
  inline void clear_col();
  static const int kColFieldNumber = 1;
  inline const ::tinytable::col& col(int index) const;
  inline ::tinytable::col* mutable_col(int index);
  inline ::tinytable::col* add_col();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::col >&
      col() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::col >*
      mutable_col();
  
  // @@protoc_insertion_point(class_scope:tinytable.slave)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::col > col_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static slave* default_instance_;
};
// -------------------------------------------------------------------

class cluster : public ::google::protobuf::Message {
 public:
  cluster();
  virtual ~cluster();
  
  cluster(const cluster& from);
  
  inline cluster& operator=(const cluster& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const cluster& default_instance();
  
  void Swap(cluster* other);
  
  // implements Message ----------------------------------------------
  
  cluster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cluster& from);
  void MergeFrom(const cluster& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .tinytable.master master = 1;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 1;
  inline const ::tinytable::master& master() const;
  inline ::tinytable::master* mutable_master();
  
  // required .tinytable.slave slave = 2;
  inline bool has_slave() const;
  inline void clear_slave();
  static const int kSlaveFieldNumber = 2;
  inline const ::tinytable::slave& slave() const;
  inline ::tinytable::slave* mutable_slave();
  
  // @@protoc_insertion_point(class_scope:tinytable.cluster)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::tinytable::master* master_;
  ::tinytable::slave* slave_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static cluster* default_instance_;
};
// -------------------------------------------------------------------

class clusters : public ::google::protobuf::Message {
 public:
  clusters();
  virtual ~clusters();
  
  clusters(const clusters& from);
  
  inline clusters& operator=(const clusters& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const clusters& default_instance();
  
  void Swap(clusters* other);
  
  // implements Message ----------------------------------------------
  
  clusters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const clusters& from);
  void MergeFrom(const clusters& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.cluster cluster = 1;
  inline int cluster_size() const;
  inline void clear_cluster();
  static const int kClusterFieldNumber = 1;
  inline const ::tinytable::cluster& cluster(int index) const;
  inline ::tinytable::cluster* mutable_cluster(int index);
  inline ::tinytable::cluster* add_cluster();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::cluster >&
      cluster() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::cluster >*
      mutable_cluster();
  
  // @@protoc_insertion_point(class_scope:tinytable.clusters)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::cluster > cluster_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static clusters* default_instance_;
};
// -------------------------------------------------------------------

class sort : public ::google::protobuf::Message {
 public:
  sort();
  virtual ~sort();
  
  sort(const sort& from);
  
  inline sort& operator=(const sort& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const sort& default_instance();
  
  void Swap(sort* other);
  
  // implements Message ----------------------------------------------
  
  sort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sort& from);
  void MergeFrom(const sort& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  
  // optional .tinytable.master master = 2;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 2;
  inline const ::tinytable::master& master() const;
  inline ::tinytable::master* mutable_master();
  
  // optional .tinytable.slave slave = 3;
  inline bool has_slave() const;
  inline void clear_slave();
  static const int kSlaveFieldNumber = 3;
  inline const ::tinytable::slave& slave() const;
  inline ::tinytable::slave* mutable_slave();
  
  // @@protoc_insertion_point(class_scope:tinytable.sort)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* type_;
  static const ::std::string _default_type_;
  ::tinytable::master* master_;
  ::tinytable::slave* slave_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static sort* default_instance_;
};
// -------------------------------------------------------------------

class sorts : public ::google::protobuf::Message {
 public:
  sorts();
  virtual ~sorts();
  
  sorts(const sorts& from);
  
  inline sorts& operator=(const sorts& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const sorts& default_instance();
  
  void Swap(sorts* other);
  
  // implements Message ----------------------------------------------
  
  sorts* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sorts& from);
  void MergeFrom(const sorts& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.sort sort = 1;
  inline int sort_size() const;
  inline void clear_sort();
  static const int kSortFieldNumber = 1;
  inline const ::tinytable::sort& sort(int index) const;
  inline ::tinytable::sort* mutable_sort(int index);
  inline ::tinytable::sort* add_sort();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::sort >&
      sort() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::sort >*
      mutable_sort();
  
  // @@protoc_insertion_point(class_scope:tinytable.sorts)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::sort > sort_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static sorts* default_instance_;
};
// -------------------------------------------------------------------

class queue : public ::google::protobuf::Message {
 public:
  queue();
  virtual ~queue();
  
  queue(const queue& from);
  
  inline queue& operator=(const queue& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const queue& default_instance();
  
  void Swap(queue* other);
  
  // implements Message ----------------------------------------------
  
  queue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const queue& from);
  void MergeFrom(const queue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  
  // optional int32 max_size = 2;
  inline bool has_max_size() const;
  inline void clear_max_size();
  static const int kMaxSizeFieldNumber = 2;
  inline ::google::protobuf::int32 max_size() const;
  inline void set_max_size(::google::protobuf::int32 value);
  
  // optional .tinytable.master master = 3;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 3;
  inline const ::tinytable::master& master() const;
  inline ::tinytable::master* mutable_master();
  
  // optional .tinytable.slave slave = 4;
  inline bool has_slave() const;
  inline void clear_slave();
  static const int kSlaveFieldNumber = 4;
  inline const ::tinytable::slave& slave() const;
  inline ::tinytable::slave* mutable_slave();
  
  // @@protoc_insertion_point(class_scope:tinytable.queue)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* type_;
  static const ::std::string _default_type_;
  ::google::protobuf::int32 max_size_;
  ::tinytable::master* master_;
  ::tinytable::slave* slave_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static queue* default_instance_;
};
// -------------------------------------------------------------------

class queues : public ::google::protobuf::Message {
 public:
  queues();
  virtual ~queues();
  
  queues(const queues& from);
  
  inline queues& operator=(const queues& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const queues& default_instance();
  
  void Swap(queues* other);
  
  // implements Message ----------------------------------------------
  
  queues* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const queues& from);
  void MergeFrom(const queues& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.queue queue = 1;
  inline int queue_size() const;
  inline void clear_queue();
  static const int kQueueFieldNumber = 1;
  inline const ::tinytable::queue& queue(int index) const;
  inline ::tinytable::queue* mutable_queue(int index);
  inline ::tinytable::queue* add_queue();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::queue >&
      queue() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::queue >*
      mutable_queue();
  
  // @@protoc_insertion_point(class_scope:tinytable.queues)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::queue > queue_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static queues* default_instance_;
};
// -------------------------------------------------------------------

class condition : public ::google::protobuf::Message {
 public:
  condition();
  virtual ~condition();
  
  condition(const condition& from);
  
  inline condition& operator=(const condition& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const condition& default_instance();
  
  void Swap(condition* other);
  
  // implements Message ----------------------------------------------
  
  condition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const condition& from);
  void MergeFrom(const condition& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 interval_s = 1;
  inline bool has_interval_s() const;
  inline void clear_interval_s();
  static const int kIntervalSFieldNumber = 1;
  inline ::google::protobuf::int32 interval_s() const;
  inline void set_interval_s(::google::protobuf::int32 value);
  
  // optional int32 interval_ms = 2;
  inline bool has_interval_ms() const;
  inline void clear_interval_ms();
  static const int kIntervalMsFieldNumber = 2;
  inline ::google::protobuf::int32 interval_ms() const;
  inline void set_interval_ms(::google::protobuf::int32 value);
  
  // optional int32 weekday = 3;
  inline bool has_weekday() const;
  inline void clear_weekday();
  static const int kWeekdayFieldNumber = 3;
  inline ::google::protobuf::int32 weekday() const;
  inline void set_weekday(::google::protobuf::int32 value);
  
  // optional int32 hour = 4;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 4;
  inline ::google::protobuf::int32 hour() const;
  inline void set_hour(::google::protobuf::int32 value);
  
  // optional int32 minute = 5;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 5;
  inline ::google::protobuf::int32 minute() const;
  inline void set_minute(::google::protobuf::int32 value);
  
  // optional int32 second = 6;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 6;
  inline ::google::protobuf::int32 second() const;
  inline void set_second(::google::protobuf::int32 value);
  
  // optional string desc = 7;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 7;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  
  // @@protoc_insertion_point(class_scope:tinytable.condition)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 interval_s_;
  ::google::protobuf::int32 interval_ms_;
  ::google::protobuf::int32 weekday_;
  ::google::protobuf::int32 hour_;
  ::google::protobuf::int32 minute_;
  ::google::protobuf::int32 second_;
  ::std::string* desc_;
  static const ::std::string _default_desc_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static condition* default_instance_;
};
// -------------------------------------------------------------------

class colfunc : public ::google::protobuf::Message {
 public:
  colfunc();
  virtual ~colfunc();
  
  colfunc(const colfunc& from);
  
  inline colfunc& operator=(const colfunc& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const colfunc& default_instance();
  
  void Swap(colfunc* other);
  
  // implements Message ----------------------------------------------
  
  colfunc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const colfunc& from);
  void MergeFrom(const colfunc& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required string ops_type = 2;
  inline bool has_ops_type() const;
  inline void clear_ops_type();
  static const int kOpsTypeFieldNumber = 2;
  inline const ::std::string& ops_type() const;
  inline void set_ops_type(const ::std::string& value);
  inline void set_ops_type(const char* value);
  inline void set_ops_type(const char* value, size_t size);
  inline ::std::string* mutable_ops_type();
  
  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // optional string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  
  // optional string min = 5;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 5;
  inline const ::std::string& min() const;
  inline void set_min(const ::std::string& value);
  inline void set_min(const char* value);
  inline void set_min(const char* value, size_t size);
  inline ::std::string* mutable_min();
  
  // optional string max = 6;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 6;
  inline const ::std::string& max() const;
  inline void set_max(const ::std::string& value);
  inline void set_max(const char* value);
  inline void set_max(const char* value, size_t size);
  inline ::std::string* mutable_max();
  
  // @@protoc_insertion_point(class_scope:tinytable.colfunc)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* ops_type_;
  static const ::std::string _default_ops_type_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::std::string* desc_;
  static const ::std::string _default_desc_;
  ::std::string* min_;
  static const ::std::string _default_min_;
  ::std::string* max_;
  static const ::std::string _default_max_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static colfunc* default_instance_;
};
// -------------------------------------------------------------------

class func : public ::google::protobuf::Message {
 public:
  func();
  virtual ~func();
  
  func(const func& from);
  
  inline func& operator=(const func& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const func& default_instance();
  
  void Swap(func* other);
  
  // implements Message ----------------------------------------------
  
  func* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const func& from);
  void MergeFrom(const func& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.colfunc colfunc = 1;
  inline int colfunc_size() const;
  inline void clear_colfunc();
  static const int kColfuncFieldNumber = 1;
  inline const ::tinytable::colfunc& colfunc(int index) const;
  inline ::tinytable::colfunc* mutable_colfunc(int index);
  inline ::tinytable::colfunc* add_colfunc();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::colfunc >&
      colfunc() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::colfunc >*
      mutable_colfunc();
  
  // @@protoc_insertion_point(class_scope:tinytable.func)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::colfunc > colfunc_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static func* default_instance_;
};
// -------------------------------------------------------------------

class timertrigger : public ::google::protobuf::Message {
 public:
  timertrigger();
  virtual ~timertrigger();
  
  timertrigger(const timertrigger& from);
  
  inline timertrigger& operator=(const timertrigger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const timertrigger& default_instance();
  
  void Swap(timertrigger* other);
  
  // implements Message ----------------------------------------------
  
  timertrigger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const timertrigger& from);
  void MergeFrom(const timertrigger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  
  // required string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  
  // required string timecol = 4;
  inline bool has_timecol() const;
  inline void clear_timecol();
  static const int kTimecolFieldNumber = 4;
  inline const ::std::string& timecol() const;
  inline void set_timecol(const ::std::string& value);
  inline void set_timecol(const char* value);
  inline void set_timecol(const char* value, size_t size);
  inline ::std::string* mutable_timecol();
  
  // required .tinytable.condition condition = 5;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 5;
  inline const ::tinytable::condition& condition() const;
  inline ::tinytable::condition* mutable_condition();
  
  // required .tinytable.func func = 6;
  inline bool has_func() const;
  inline void clear_func();
  static const int kFuncFieldNumber = 6;
  inline const ::tinytable::func& func() const;
  inline ::tinytable::func* mutable_func();
  
  // @@protoc_insertion_point(class_scope:tinytable.timertrigger)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* desc_;
  static const ::std::string _default_desc_;
  ::std::string* type_;
  static const ::std::string _default_type_;
  ::std::string* timecol_;
  static const ::std::string _default_timecol_;
  ::tinytable::condition* condition_;
  ::tinytable::func* func_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static timertrigger* default_instance_;
};
// -------------------------------------------------------------------

class timertriggers : public ::google::protobuf::Message {
 public:
  timertriggers();
  virtual ~timertriggers();
  
  timertriggers(const timertriggers& from);
  
  inline timertriggers& operator=(const timertriggers& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const timertriggers& default_instance();
  
  void Swap(timertriggers* other);
  
  // implements Message ----------------------------------------------
  
  timertriggers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const timertriggers& from);
  void MergeFrom(const timertriggers& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.timertrigger timertrigger = 1;
  inline int timertrigger_size() const;
  inline void clear_timertrigger();
  static const int kTimertriggerFieldNumber = 1;
  inline const ::tinytable::timertrigger& timertrigger(int index) const;
  inline ::tinytable::timertrigger* mutable_timertrigger(int index);
  inline ::tinytable::timertrigger* add_timertrigger();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::timertrigger >&
      timertrigger() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::timertrigger >*
      mutable_timertrigger();
  
  // @@protoc_insertion_point(class_scope:tinytable.timertriggers)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::timertrigger > timertrigger_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static timertriggers* default_instance_;
};
// -------------------------------------------------------------------

class triggers : public ::google::protobuf::Message {
 public:
  triggers();
  virtual ~triggers();
  
  triggers(const triggers& from);
  
  inline triggers& operator=(const triggers& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const triggers& default_instance();
  
  void Swap(triggers* other);
  
  // implements Message ----------------------------------------------
  
  triggers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const triggers& from);
  void MergeFrom(const triggers& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .tinytable.timertriggers timertriggers = 1;
  inline bool has_timertriggers() const;
  inline void clear_timertriggers();
  static const int kTimertriggersFieldNumber = 1;
  inline const ::tinytable::timertriggers& timertriggers() const;
  inline ::tinytable::timertriggers* mutable_timertriggers();
  
  // @@protoc_insertion_point(class_scope:tinytable.triggers)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::tinytable::timertriggers* timertriggers_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static triggers* default_instance_;
};
// -------------------------------------------------------------------

class tinytable : public ::google::protobuf::Message {
 public:
  tinytable();
  virtual ~tinytable();
  
  tinytable(const tinytable& from);
  
  inline tinytable& operator=(const tinytable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const tinytable& default_instance();
  
  void Swap(tinytable* other);
  
  // implements Message ----------------------------------------------
  
  tinytable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tinytable& from);
  void MergeFrom(const tinytable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  
  // optional string servercol = 3;
  inline bool has_servercol() const;
  inline void clear_servercol();
  static const int kServercolFieldNumber = 3;
  inline const ::std::string& servercol() const;
  inline void set_servercol(const ::std::string& value);
  inline void set_servercol(const char* value);
  inline void set_servercol(const char* value, size_t size);
  inline ::std::string* mutable_servercol();
  
  // required int32 expired = 4;
  inline bool has_expired() const;
  inline void clear_expired();
  static const int kExpiredFieldNumber = 4;
  inline ::google::protobuf::int32 expired() const;
  inline void set_expired(::google::protobuf::int32 value);
  
  // optional string loadtype = 5;
  inline bool has_loadtype() const;
  inline void clear_loadtype();
  static const int kLoadtypeFieldNumber = 5;
  inline const ::std::string& loadtype() const;
  inline void set_loadtype(const ::std::string& value);
  inline void set_loadtype(const char* value);
  inline void set_loadtype(const char* value, size_t size);
  inline ::std::string* mutable_loadtype();
  
  // optional string type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  
  // optional string firstsource = 7;
  inline bool has_firstsource() const;
  inline void clear_firstsource();
  static const int kFirstsourceFieldNumber = 7;
  inline const ::std::string& firstsource() const;
  inline void set_firstsource(const ::std::string& value);
  inline void set_firstsource(const char* value);
  inline void set_firstsource(const char* value, size_t size);
  inline ::std::string* mutable_firstsource();
  
  // optional string updatetype = 8;
  inline bool has_updatetype() const;
  inline void clear_updatetype();
  static const int kUpdatetypeFieldNumber = 8;
  inline const ::std::string& updatetype() const;
  inline void set_updatetype(const ::std::string& value);
  inline void set_updatetype(const char* value);
  inline void set_updatetype(const char* value, size_t size);
  inline ::std::string* mutable_updatetype();
  
  // optional .tinytable.columns columns = 9;
  inline bool has_columns() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 9;
  inline const ::tinytable::columns& columns() const;
  inline ::tinytable::columns* mutable_columns();
  
  // optional .tinytable.uniques uniques = 10;
  inline bool has_uniques() const;
  inline void clear_uniques();
  static const int kUniquesFieldNumber = 10;
  inline const ::tinytable::uniques& uniques() const;
  inline ::tinytable::uniques* mutable_uniques();
  
  // optional .tinytable.clusters clusters = 11;
  inline bool has_clusters() const;
  inline void clear_clusters();
  static const int kClustersFieldNumber = 11;
  inline const ::tinytable::clusters& clusters() const;
  inline ::tinytable::clusters* mutable_clusters();
  
  // optional .tinytable.sorts sorts = 12;
  inline bool has_sorts() const;
  inline void clear_sorts();
  static const int kSortsFieldNumber = 12;
  inline const ::tinytable::sorts& sorts() const;
  inline ::tinytable::sorts* mutable_sorts();
  
  // optional .tinytable.triggers triggers = 13;
  inline bool has_triggers() const;
  inline void clear_triggers();
  static const int kTriggersFieldNumber = 13;
  inline const ::tinytable::triggers& triggers() const;
  inline ::tinytable::triggers* mutable_triggers();
  
  // optional .tinytable.queues queues = 14;
  inline bool has_queues() const;
  inline void clear_queues();
  static const int kQueuesFieldNumber = 14;
  inline const ::tinytable::queues& queues() const;
  inline ::tinytable::queues* mutable_queues();
  
  // @@protoc_insertion_point(class_scope:tinytable.tinytable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* desc_;
  static const ::std::string _default_desc_;
  ::std::string* servercol_;
  static const ::std::string _default_servercol_;
  ::google::protobuf::int32 expired_;
  ::std::string* loadtype_;
  static const ::std::string _default_loadtype_;
  ::std::string* type_;
  static const ::std::string _default_type_;
  ::std::string* firstsource_;
  static const ::std::string _default_firstsource_;
  ::std::string* updatetype_;
  static const ::std::string _default_updatetype_;
  ::tinytable::columns* columns_;
  ::tinytable::uniques* uniques_;
  ::tinytable::clusters* clusters_;
  ::tinytable::sorts* sorts_;
  ::tinytable::triggers* triggers_;
  ::tinytable::queues* queues_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static tinytable* default_instance_;
};
// -------------------------------------------------------------------

class table : public ::google::protobuf::Message {
 public:
  table();
  virtual ~table();
  
  table(const table& from);
  
  inline table& operator=(const table& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const table& default_instance();
  
  void Swap(table* other);
  
  // implements Message ----------------------------------------------
  
  table* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const table& from);
  void MergeFrom(const table& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string update_type = 2;
  inline bool has_update_type() const;
  inline void clear_update_type();
  static const int kUpdateTypeFieldNumber = 2;
  inline const ::std::string& update_type() const;
  inline void set_update_type(const ::std::string& value);
  inline void set_update_type(const char* value);
  inline void set_update_type(const char* value, size_t size);
  inline ::std::string* mutable_update_type();
  
  // optional int32 save = 3;
  inline bool has_save() const;
  inline void clear_save();
  static const int kSaveFieldNumber = 3;
  inline ::google::protobuf::int32 save() const;
  inline void set_save(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:tinytable.table)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* update_type_;
  static const ::std::string _default_update_type_;
  ::google::protobuf::int32 save_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static table* default_instance_;
};
// -------------------------------------------------------------------

class tables : public ::google::protobuf::Message {
 public:
  tables();
  virtual ~tables();
  
  tables(const tables& from);
  
  inline tables& operator=(const tables& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const tables& default_instance();
  
  void Swap(tables* other);
  
  // implements Message ----------------------------------------------
  
  tables* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tables& from);
  void MergeFrom(const tables& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.table table = 1;
  inline int table_size() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::tinytable::table& table(int index) const;
  inline ::tinytable::table* mutable_table(int index);
  inline ::tinytable::table* add_table();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::table >&
      table() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::table >*
      mutable_table();
  
  // @@protoc_insertion_point(class_scope:tinytable.tables)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::table > table_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static tables* default_instance_;
};
// -------------------------------------------------------------------

class tablecol : public ::google::protobuf::Message {
 public:
  tablecol();
  virtual ~tablecol();
  
  tablecol(const tablecol& from);
  
  inline tablecol& operator=(const tablecol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const tablecol& default_instance();
  
  void Swap(tablecol* other);
  
  // implements Message ----------------------------------------------
  
  tablecol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tablecol& from);
  void MergeFrom(const tablecol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .tinytable.cols cols = 2;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 2;
  inline const ::tinytable::cols& cols() const;
  inline ::tinytable::cols* mutable_cols();
  
  // @@protoc_insertion_point(class_scope:tinytable.tablecol)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::tinytable::cols* cols_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static tablecol* default_instance_;
};
// -------------------------------------------------------------------

class tablecols : public ::google::protobuf::Message {
 public:
  tablecols();
  virtual ~tablecols();
  
  tablecols(const tablecols& from);
  
  inline tablecols& operator=(const tablecols& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const tablecols& default_instance();
  
  void Swap(tablecols* other);
  
  // implements Message ----------------------------------------------
  
  tablecols* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tablecols& from);
  void MergeFrom(const tablecols& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.tablecol tablecol = 1;
  inline int tablecol_size() const;
  inline void clear_tablecol();
  static const int kTablecolFieldNumber = 1;
  inline const ::tinytable::tablecol& tablecol(int index) const;
  inline ::tinytable::tablecol* mutable_tablecol(int index);
  inline ::tinytable::tablecol* add_tablecol();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::tablecol >&
      tablecol() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::tablecol >*
      mutable_tablecol();
  
  // @@protoc_insertion_point(class_scope:tinytable.tablecols)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::tablecol > tablecol_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static tablecols* default_instance_;
};
// -------------------------------------------------------------------

class expire : public ::google::protobuf::Message {
 public:
  expire();
  virtual ~expire();
  
  expire(const expire& from);
  
  inline expire& operator=(const expire& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const expire& default_instance();
  
  void Swap(expire* other);
  
  // implements Message ----------------------------------------------
  
  expire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const expire& from);
  void MergeFrom(const expire& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required int32 timeout = 2;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);
  
  // required .tinytable.tablecols tablecols = 3;
  inline bool has_tablecols() const;
  inline void clear_tablecols();
  static const int kTablecolsFieldNumber = 3;
  inline const ::tinytable::tablecols& tablecols() const;
  inline ::tinytable::tablecols* mutable_tablecols();
  
  // @@protoc_insertion_point(class_scope:tinytable.expire)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 timeout_;
  ::tinytable::tablecols* tablecols_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static expire* default_instance_;
};
// -------------------------------------------------------------------

class expires : public ::google::protobuf::Message {
 public:
  expires();
  virtual ~expires();
  
  expires(const expires& from);
  
  inline expires& operator=(const expires& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const expires& default_instance();
  
  void Swap(expires* other);
  
  // implements Message ----------------------------------------------
  
  expires* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const expires& from);
  void MergeFrom(const expires& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tinytable.expire expire = 1;
  inline int expire_size() const;
  inline void clear_expire();
  static const int kExpireFieldNumber = 1;
  inline const ::tinytable::expire& expire(int index) const;
  inline ::tinytable::expire* mutable_expire(int index);
  inline ::tinytable::expire* add_expire();
  inline const ::google::protobuf::RepeatedPtrField< ::tinytable::expire >&
      expire() const;
  inline ::google::protobuf::RepeatedPtrField< ::tinytable::expire >*
      mutable_expire();
  
  // @@protoc_insertion_point(class_scope:tinytable.expires)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::tinytable::expire > expire_;
  friend void  protobuf_AddDesc_tinytable_2eproto();
  friend void protobuf_AssignDesc_tinytable_2eproto();
  friend void protobuf_ShutdownFile_tinytable_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static expires* default_instance_;
};
// ===================================================================


// ===================================================================

// columns

// repeated .tinytable.column column = 1;
inline int columns::column_size() const {
  return column_.size();
}
inline void columns::clear_column() {
  column_.Clear();
}
inline const ::tinytable::column& columns::column(int index) const {
  return column_.Get(index);
}
inline ::tinytable::column* columns::mutable_column(int index) {
  return column_.Mutable(index);
}
inline ::tinytable::column* columns::add_column() {
  return column_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::column >&
columns::column() const {
  return column_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::column >*
columns::mutable_column() {
  return &column_;
}

// -------------------------------------------------------------------

// column

// required string name = 1;
inline bool column::has_name() const {
  return _has_bit(0);
}
inline void column::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& column::name() const {
  return *name_;
}
inline void column::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void column::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void column::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* column::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string datatype = 2;
inline bool column::has_datatype() const {
  return _has_bit(1);
}
inline void column::clear_datatype() {
  if (datatype_ != &_default_datatype_) {
    datatype_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& column::datatype() const {
  return *datatype_;
}
inline void column::set_datatype(const ::std::string& value) {
  _set_bit(1);
  if (datatype_ == &_default_datatype_) {
    datatype_ = new ::std::string;
  }
  datatype_->assign(value);
}
inline void column::set_datatype(const char* value) {
  _set_bit(1);
  if (datatype_ == &_default_datatype_) {
    datatype_ = new ::std::string;
  }
  datatype_->assign(value);
}
inline void column::set_datatype(const char* value, size_t size) {
  _set_bit(1);
  if (datatype_ == &_default_datatype_) {
    datatype_ = new ::std::string;
  }
  datatype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* column::mutable_datatype() {
  _set_bit(1);
  if (datatype_ == &_default_datatype_) {
    datatype_ = new ::std::string;
  }
  return datatype_;
}

// optional int32 maxlen = 3;
inline bool column::has_maxlen() const {
  return _has_bit(2);
}
inline void column::clear_maxlen() {
  maxlen_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 column::maxlen() const {
  return maxlen_;
}
inline void column::set_maxlen(::google::protobuf::int32 value) {
  _set_bit(2);
  maxlen_ = value;
}

// optional bool is_primary = 4;
inline bool column::has_is_primary() const {
  return _has_bit(3);
}
inline void column::clear_is_primary() {
  is_primary_ = false;
  _clear_bit(3);
}
inline bool column::is_primary() const {
  return is_primary_;
}
inline void column::set_is_primary(bool value) {
  _set_bit(3);
  is_primary_ = value;
}

// optional string desc = 5;
inline bool column::has_desc() const {
  return _has_bit(4);
}
inline void column::clear_desc() {
  if (desc_ != &_default_desc_) {
    desc_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& column::desc() const {
  return *desc_;
}
inline void column::set_desc(const ::std::string& value) {
  _set_bit(4);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void column::set_desc(const char* value) {
  _set_bit(4);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void column::set_desc(const char* value, size_t size) {
  _set_bit(4);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* column::mutable_desc() {
  _set_bit(4);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  return desc_;
}

// optional int32 serial = 6;
inline bool column::has_serial() const {
  return _has_bit(5);
}
inline void column::clear_serial() {
  serial_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 column::serial() const {
  return serial_;
}
inline void column::set_serial(::google::protobuf::int32 value) {
  _set_bit(5);
  serial_ = value;
}

// -------------------------------------------------------------------

// col

// required string name = 1;
inline bool col::has_name() const {
  return _has_bit(0);
}
inline void col::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& col::name() const {
  return *name_;
}
inline void col::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void col::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void col::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* col::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// cols

// repeated .tinytable.col col = 1;
inline int cols::col_size() const {
  return col_.size();
}
inline void cols::clear_col() {
  col_.Clear();
}
inline const ::tinytable::col& cols::col(int index) const {
  return col_.Get(index);
}
inline ::tinytable::col* cols::mutable_col(int index) {
  return col_.Mutable(index);
}
inline ::tinytable::col* cols::add_col() {
  return col_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::col >&
cols::col() const {
  return col_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::col >*
cols::mutable_col() {
  return &col_;
}

// -------------------------------------------------------------------

// uniques

// repeated .tinytable.unique unique = 1;
inline int uniques::unique_size() const {
  return unique_.size();
}
inline void uniques::clear_unique() {
  unique_.Clear();
}
inline const ::tinytable::unique& uniques::unique(int index) const {
  return unique_.Get(index);
}
inline ::tinytable::unique* uniques::mutable_unique(int index) {
  return unique_.Mutable(index);
}
inline ::tinytable::unique* uniques::add_unique() {
  return unique_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::unique >&
uniques::unique() const {
  return unique_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::unique >*
uniques::mutable_unique() {
  return &unique_;
}

// -------------------------------------------------------------------

// unique

// repeated .tinytable.col col = 1;
inline int unique::col_size() const {
  return col_.size();
}
inline void unique::clear_col() {
  col_.Clear();
}
inline const ::tinytable::col& unique::col(int index) const {
  return col_.Get(index);
}
inline ::tinytable::col* unique::mutable_col(int index) {
  return col_.Mutable(index);
}
inline ::tinytable::col* unique::add_col() {
  return col_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::col >&
unique::col() const {
  return col_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::col >*
unique::mutable_col() {
  return &col_;
}

// -------------------------------------------------------------------

// master

// repeated .tinytable.col col = 1;
inline int master::col_size() const {
  return col_.size();
}
inline void master::clear_col() {
  col_.Clear();
}
inline const ::tinytable::col& master::col(int index) const {
  return col_.Get(index);
}
inline ::tinytable::col* master::mutable_col(int index) {
  return col_.Mutable(index);
}
inline ::tinytable::col* master::add_col() {
  return col_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::col >&
master::col() const {
  return col_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::col >*
master::mutable_col() {
  return &col_;
}

// -------------------------------------------------------------------

// slave

// repeated .tinytable.col col = 1;
inline int slave::col_size() const {
  return col_.size();
}
inline void slave::clear_col() {
  col_.Clear();
}
inline const ::tinytable::col& slave::col(int index) const {
  return col_.Get(index);
}
inline ::tinytable::col* slave::mutable_col(int index) {
  return col_.Mutable(index);
}
inline ::tinytable::col* slave::add_col() {
  return col_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::col >&
slave::col() const {
  return col_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::col >*
slave::mutable_col() {
  return &col_;
}

// -------------------------------------------------------------------

// cluster

// required .tinytable.master master = 1;
inline bool cluster::has_master() const {
  return _has_bit(0);
}
inline void cluster::clear_master() {
  if (master_ != NULL) master_->::tinytable::master::Clear();
  _clear_bit(0);
}
inline const ::tinytable::master& cluster::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::tinytable::master* cluster::mutable_master() {
  _set_bit(0);
  if (master_ == NULL) master_ = new ::tinytable::master;
  return master_;
}

// required .tinytable.slave slave = 2;
inline bool cluster::has_slave() const {
  return _has_bit(1);
}
inline void cluster::clear_slave() {
  if (slave_ != NULL) slave_->::tinytable::slave::Clear();
  _clear_bit(1);
}
inline const ::tinytable::slave& cluster::slave() const {
  return slave_ != NULL ? *slave_ : *default_instance_->slave_;
}
inline ::tinytable::slave* cluster::mutable_slave() {
  _set_bit(1);
  if (slave_ == NULL) slave_ = new ::tinytable::slave;
  return slave_;
}

// -------------------------------------------------------------------

// clusters

// repeated .tinytable.cluster cluster = 1;
inline int clusters::cluster_size() const {
  return cluster_.size();
}
inline void clusters::clear_cluster() {
  cluster_.Clear();
}
inline const ::tinytable::cluster& clusters::cluster(int index) const {
  return cluster_.Get(index);
}
inline ::tinytable::cluster* clusters::mutable_cluster(int index) {
  return cluster_.Mutable(index);
}
inline ::tinytable::cluster* clusters::add_cluster() {
  return cluster_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::cluster >&
clusters::cluster() const {
  return cluster_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::cluster >*
clusters::mutable_cluster() {
  return &cluster_;
}

// -------------------------------------------------------------------

// sort

// optional string type = 1;
inline bool sort::has_type() const {
  return _has_bit(0);
}
inline void sort::clear_type() {
  if (type_ != &_default_type_) {
    type_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& sort::type() const {
  return *type_;
}
inline void sort::set_type(const ::std::string& value) {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void sort::set_type(const char* value) {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void sort::set_type(const char* value, size_t size) {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sort::mutable_type() {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  return type_;
}

// optional .tinytable.master master = 2;
inline bool sort::has_master() const {
  return _has_bit(1);
}
inline void sort::clear_master() {
  if (master_ != NULL) master_->::tinytable::master::Clear();
  _clear_bit(1);
}
inline const ::tinytable::master& sort::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::tinytable::master* sort::mutable_master() {
  _set_bit(1);
  if (master_ == NULL) master_ = new ::tinytable::master;
  return master_;
}

// optional .tinytable.slave slave = 3;
inline bool sort::has_slave() const {
  return _has_bit(2);
}
inline void sort::clear_slave() {
  if (slave_ != NULL) slave_->::tinytable::slave::Clear();
  _clear_bit(2);
}
inline const ::tinytable::slave& sort::slave() const {
  return slave_ != NULL ? *slave_ : *default_instance_->slave_;
}
inline ::tinytable::slave* sort::mutable_slave() {
  _set_bit(2);
  if (slave_ == NULL) slave_ = new ::tinytable::slave;
  return slave_;
}

// -------------------------------------------------------------------

// sorts

// repeated .tinytable.sort sort = 1;
inline int sorts::sort_size() const {
  return sort_.size();
}
inline void sorts::clear_sort() {
  sort_.Clear();
}
inline const ::tinytable::sort& sorts::sort(int index) const {
  return sort_.Get(index);
}
inline ::tinytable::sort* sorts::mutable_sort(int index) {
  return sort_.Mutable(index);
}
inline ::tinytable::sort* sorts::add_sort() {
  return sort_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::sort >&
sorts::sort() const {
  return sort_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::sort >*
sorts::mutable_sort() {
  return &sort_;
}

// -------------------------------------------------------------------

// queue

// optional string type = 1;
inline bool queue::has_type() const {
  return _has_bit(0);
}
inline void queue::clear_type() {
  if (type_ != &_default_type_) {
    type_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& queue::type() const {
  return *type_;
}
inline void queue::set_type(const ::std::string& value) {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void queue::set_type(const char* value) {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void queue::set_type(const char* value, size_t size) {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* queue::mutable_type() {
  _set_bit(0);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  return type_;
}

// optional int32 max_size = 2;
inline bool queue::has_max_size() const {
  return _has_bit(1);
}
inline void queue::clear_max_size() {
  max_size_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 queue::max_size() const {
  return max_size_;
}
inline void queue::set_max_size(::google::protobuf::int32 value) {
  _set_bit(1);
  max_size_ = value;
}

// optional .tinytable.master master = 3;
inline bool queue::has_master() const {
  return _has_bit(2);
}
inline void queue::clear_master() {
  if (master_ != NULL) master_->::tinytable::master::Clear();
  _clear_bit(2);
}
inline const ::tinytable::master& queue::master() const {
  return master_ != NULL ? *master_ : *default_instance_->master_;
}
inline ::tinytable::master* queue::mutable_master() {
  _set_bit(2);
  if (master_ == NULL) master_ = new ::tinytable::master;
  return master_;
}

// optional .tinytable.slave slave = 4;
inline bool queue::has_slave() const {
  return _has_bit(3);
}
inline void queue::clear_slave() {
  if (slave_ != NULL) slave_->::tinytable::slave::Clear();
  _clear_bit(3);
}
inline const ::tinytable::slave& queue::slave() const {
  return slave_ != NULL ? *slave_ : *default_instance_->slave_;
}
inline ::tinytable::slave* queue::mutable_slave() {
  _set_bit(3);
  if (slave_ == NULL) slave_ = new ::tinytable::slave;
  return slave_;
}

// -------------------------------------------------------------------

// queues

// repeated .tinytable.queue queue = 1;
inline int queues::queue_size() const {
  return queue_.size();
}
inline void queues::clear_queue() {
  queue_.Clear();
}
inline const ::tinytable::queue& queues::queue(int index) const {
  return queue_.Get(index);
}
inline ::tinytable::queue* queues::mutable_queue(int index) {
  return queue_.Mutable(index);
}
inline ::tinytable::queue* queues::add_queue() {
  return queue_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::queue >&
queues::queue() const {
  return queue_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::queue >*
queues::mutable_queue() {
  return &queue_;
}

// -------------------------------------------------------------------

// condition

// optional int32 interval_s = 1;
inline bool condition::has_interval_s() const {
  return _has_bit(0);
}
inline void condition::clear_interval_s() {
  interval_s_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 condition::interval_s() const {
  return interval_s_;
}
inline void condition::set_interval_s(::google::protobuf::int32 value) {
  _set_bit(0);
  interval_s_ = value;
}

// optional int32 interval_ms = 2;
inline bool condition::has_interval_ms() const {
  return _has_bit(1);
}
inline void condition::clear_interval_ms() {
  interval_ms_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 condition::interval_ms() const {
  return interval_ms_;
}
inline void condition::set_interval_ms(::google::protobuf::int32 value) {
  _set_bit(1);
  interval_ms_ = value;
}

// optional int32 weekday = 3;
inline bool condition::has_weekday() const {
  return _has_bit(2);
}
inline void condition::clear_weekday() {
  weekday_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 condition::weekday() const {
  return weekday_;
}
inline void condition::set_weekday(::google::protobuf::int32 value) {
  _set_bit(2);
  weekday_ = value;
}

// optional int32 hour = 4;
inline bool condition::has_hour() const {
  return _has_bit(3);
}
inline void condition::clear_hour() {
  hour_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 condition::hour() const {
  return hour_;
}
inline void condition::set_hour(::google::protobuf::int32 value) {
  _set_bit(3);
  hour_ = value;
}

// optional int32 minute = 5;
inline bool condition::has_minute() const {
  return _has_bit(4);
}
inline void condition::clear_minute() {
  minute_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 condition::minute() const {
  return minute_;
}
inline void condition::set_minute(::google::protobuf::int32 value) {
  _set_bit(4);
  minute_ = value;
}

// optional int32 second = 6;
inline bool condition::has_second() const {
  return _has_bit(5);
}
inline void condition::clear_second() {
  second_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 condition::second() const {
  return second_;
}
inline void condition::set_second(::google::protobuf::int32 value) {
  _set_bit(5);
  second_ = value;
}

// optional string desc = 7;
inline bool condition::has_desc() const {
  return _has_bit(6);
}
inline void condition::clear_desc() {
  if (desc_ != &_default_desc_) {
    desc_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& condition::desc() const {
  return *desc_;
}
inline void condition::set_desc(const ::std::string& value) {
  _set_bit(6);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void condition::set_desc(const char* value) {
  _set_bit(6);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void condition::set_desc(const char* value, size_t size) {
  _set_bit(6);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* condition::mutable_desc() {
  _set_bit(6);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  return desc_;
}

// -------------------------------------------------------------------

// colfunc

// optional string name = 1;
inline bool colfunc::has_name() const {
  return _has_bit(0);
}
inline void colfunc::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& colfunc::name() const {
  return *name_;
}
inline void colfunc::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void colfunc::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void colfunc::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* colfunc::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string ops_type = 2;
inline bool colfunc::has_ops_type() const {
  return _has_bit(1);
}
inline void colfunc::clear_ops_type() {
  if (ops_type_ != &_default_ops_type_) {
    ops_type_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& colfunc::ops_type() const {
  return *ops_type_;
}
inline void colfunc::set_ops_type(const ::std::string& value) {
  _set_bit(1);
  if (ops_type_ == &_default_ops_type_) {
    ops_type_ = new ::std::string;
  }
  ops_type_->assign(value);
}
inline void colfunc::set_ops_type(const char* value) {
  _set_bit(1);
  if (ops_type_ == &_default_ops_type_) {
    ops_type_ = new ::std::string;
  }
  ops_type_->assign(value);
}
inline void colfunc::set_ops_type(const char* value, size_t size) {
  _set_bit(1);
  if (ops_type_ == &_default_ops_type_) {
    ops_type_ = new ::std::string;
  }
  ops_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* colfunc::mutable_ops_type() {
  _set_bit(1);
  if (ops_type_ == &_default_ops_type_) {
    ops_type_ = new ::std::string;
  }
  return ops_type_;
}

// optional string value = 3;
inline bool colfunc::has_value() const {
  return _has_bit(2);
}
inline void colfunc::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& colfunc::value() const {
  return *value_;
}
inline void colfunc::set_value(const ::std::string& value) {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void colfunc::set_value(const char* value) {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void colfunc::set_value(const char* value, size_t size) {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* colfunc::mutable_value() {
  _set_bit(2);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// optional string desc = 4;
inline bool colfunc::has_desc() const {
  return _has_bit(3);
}
inline void colfunc::clear_desc() {
  if (desc_ != &_default_desc_) {
    desc_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& colfunc::desc() const {
  return *desc_;
}
inline void colfunc::set_desc(const ::std::string& value) {
  _set_bit(3);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void colfunc::set_desc(const char* value) {
  _set_bit(3);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void colfunc::set_desc(const char* value, size_t size) {
  _set_bit(3);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* colfunc::mutable_desc() {
  _set_bit(3);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  return desc_;
}

// optional string min = 5;
inline bool colfunc::has_min() const {
  return _has_bit(4);
}
inline void colfunc::clear_min() {
  if (min_ != &_default_min_) {
    min_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& colfunc::min() const {
  return *min_;
}
inline void colfunc::set_min(const ::std::string& value) {
  _set_bit(4);
  if (min_ == &_default_min_) {
    min_ = new ::std::string;
  }
  min_->assign(value);
}
inline void colfunc::set_min(const char* value) {
  _set_bit(4);
  if (min_ == &_default_min_) {
    min_ = new ::std::string;
  }
  min_->assign(value);
}
inline void colfunc::set_min(const char* value, size_t size) {
  _set_bit(4);
  if (min_ == &_default_min_) {
    min_ = new ::std::string;
  }
  min_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* colfunc::mutable_min() {
  _set_bit(4);
  if (min_ == &_default_min_) {
    min_ = new ::std::string;
  }
  return min_;
}

// optional string max = 6;
inline bool colfunc::has_max() const {
  return _has_bit(5);
}
inline void colfunc::clear_max() {
  if (max_ != &_default_max_) {
    max_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& colfunc::max() const {
  return *max_;
}
inline void colfunc::set_max(const ::std::string& value) {
  _set_bit(5);
  if (max_ == &_default_max_) {
    max_ = new ::std::string;
  }
  max_->assign(value);
}
inline void colfunc::set_max(const char* value) {
  _set_bit(5);
  if (max_ == &_default_max_) {
    max_ = new ::std::string;
  }
  max_->assign(value);
}
inline void colfunc::set_max(const char* value, size_t size) {
  _set_bit(5);
  if (max_ == &_default_max_) {
    max_ = new ::std::string;
  }
  max_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* colfunc::mutable_max() {
  _set_bit(5);
  if (max_ == &_default_max_) {
    max_ = new ::std::string;
  }
  return max_;
}

// -------------------------------------------------------------------

// func

// repeated .tinytable.colfunc colfunc = 1;
inline int func::colfunc_size() const {
  return colfunc_.size();
}
inline void func::clear_colfunc() {
  colfunc_.Clear();
}
inline const ::tinytable::colfunc& func::colfunc(int index) const {
  return colfunc_.Get(index);
}
inline ::tinytable::colfunc* func::mutable_colfunc(int index) {
  return colfunc_.Mutable(index);
}
inline ::tinytable::colfunc* func::add_colfunc() {
  return colfunc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::colfunc >&
func::colfunc() const {
  return colfunc_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::colfunc >*
func::mutable_colfunc() {
  return &colfunc_;
}

// -------------------------------------------------------------------

// timertrigger

// optional string name = 1;
inline bool timertrigger::has_name() const {
  return _has_bit(0);
}
inline void timertrigger::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& timertrigger::name() const {
  return *name_;
}
inline void timertrigger::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void timertrigger::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void timertrigger::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* timertrigger::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string desc = 2;
inline bool timertrigger::has_desc() const {
  return _has_bit(1);
}
inline void timertrigger::clear_desc() {
  if (desc_ != &_default_desc_) {
    desc_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& timertrigger::desc() const {
  return *desc_;
}
inline void timertrigger::set_desc(const ::std::string& value) {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void timertrigger::set_desc(const char* value) {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void timertrigger::set_desc(const char* value, size_t size) {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* timertrigger::mutable_desc() {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  return desc_;
}

// required string type = 3;
inline bool timertrigger::has_type() const {
  return _has_bit(2);
}
inline void timertrigger::clear_type() {
  if (type_ != &_default_type_) {
    type_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& timertrigger::type() const {
  return *type_;
}
inline void timertrigger::set_type(const ::std::string& value) {
  _set_bit(2);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void timertrigger::set_type(const char* value) {
  _set_bit(2);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void timertrigger::set_type(const char* value, size_t size) {
  _set_bit(2);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* timertrigger::mutable_type() {
  _set_bit(2);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  return type_;
}

// required string timecol = 4;
inline bool timertrigger::has_timecol() const {
  return _has_bit(3);
}
inline void timertrigger::clear_timecol() {
  if (timecol_ != &_default_timecol_) {
    timecol_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& timertrigger::timecol() const {
  return *timecol_;
}
inline void timertrigger::set_timecol(const ::std::string& value) {
  _set_bit(3);
  if (timecol_ == &_default_timecol_) {
    timecol_ = new ::std::string;
  }
  timecol_->assign(value);
}
inline void timertrigger::set_timecol(const char* value) {
  _set_bit(3);
  if (timecol_ == &_default_timecol_) {
    timecol_ = new ::std::string;
  }
  timecol_->assign(value);
}
inline void timertrigger::set_timecol(const char* value, size_t size) {
  _set_bit(3);
  if (timecol_ == &_default_timecol_) {
    timecol_ = new ::std::string;
  }
  timecol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* timertrigger::mutable_timecol() {
  _set_bit(3);
  if (timecol_ == &_default_timecol_) {
    timecol_ = new ::std::string;
  }
  return timecol_;
}

// required .tinytable.condition condition = 5;
inline bool timertrigger::has_condition() const {
  return _has_bit(4);
}
inline void timertrigger::clear_condition() {
  if (condition_ != NULL) condition_->::tinytable::condition::Clear();
  _clear_bit(4);
}
inline const ::tinytable::condition& timertrigger::condition() const {
  return condition_ != NULL ? *condition_ : *default_instance_->condition_;
}
inline ::tinytable::condition* timertrigger::mutable_condition() {
  _set_bit(4);
  if (condition_ == NULL) condition_ = new ::tinytable::condition;
  return condition_;
}

// required .tinytable.func func = 6;
inline bool timertrigger::has_func() const {
  return _has_bit(5);
}
inline void timertrigger::clear_func() {
  if (func_ != NULL) func_->::tinytable::func::Clear();
  _clear_bit(5);
}
inline const ::tinytable::func& timertrigger::func() const {
  return func_ != NULL ? *func_ : *default_instance_->func_;
}
inline ::tinytable::func* timertrigger::mutable_func() {
  _set_bit(5);
  if (func_ == NULL) func_ = new ::tinytable::func;
  return func_;
}

// -------------------------------------------------------------------

// timertriggers

// repeated .tinytable.timertrigger timertrigger = 1;
inline int timertriggers::timertrigger_size() const {
  return timertrigger_.size();
}
inline void timertriggers::clear_timertrigger() {
  timertrigger_.Clear();
}
inline const ::tinytable::timertrigger& timertriggers::timertrigger(int index) const {
  return timertrigger_.Get(index);
}
inline ::tinytable::timertrigger* timertriggers::mutable_timertrigger(int index) {
  return timertrigger_.Mutable(index);
}
inline ::tinytable::timertrigger* timertriggers::add_timertrigger() {
  return timertrigger_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::timertrigger >&
timertriggers::timertrigger() const {
  return timertrigger_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::timertrigger >*
timertriggers::mutable_timertrigger() {
  return &timertrigger_;
}

// -------------------------------------------------------------------

// triggers

// optional .tinytable.timertriggers timertriggers = 1;
inline bool triggers::has_timertriggers() const {
  return _has_bit(0);
}
inline void triggers::clear_timertriggers() {
  if (timertriggers_ != NULL) timertriggers_->::tinytable::timertriggers::Clear();
  _clear_bit(0);
}
inline const ::tinytable::timertriggers& triggers::timertriggers() const {
  return timertriggers_ != NULL ? *timertriggers_ : *default_instance_->timertriggers_;
}
inline ::tinytable::timertriggers* triggers::mutable_timertriggers() {
  _set_bit(0);
  if (timertriggers_ == NULL) timertriggers_ = new ::tinytable::timertriggers;
  return timertriggers_;
}

// -------------------------------------------------------------------

// tinytable

// required string name = 1;
inline bool tinytable::has_name() const {
  return _has_bit(0);
}
inline void tinytable::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& tinytable::name() const {
  return *name_;
}
inline void tinytable::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void tinytable::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void tinytable::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tinytable::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string desc = 2;
inline bool tinytable::has_desc() const {
  return _has_bit(1);
}
inline void tinytable::clear_desc() {
  if (desc_ != &_default_desc_) {
    desc_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& tinytable::desc() const {
  return *desc_;
}
inline void tinytable::set_desc(const ::std::string& value) {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void tinytable::set_desc(const char* value) {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void tinytable::set_desc(const char* value, size_t size) {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tinytable::mutable_desc() {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  return desc_;
}

// optional string servercol = 3;
inline bool tinytable::has_servercol() const {
  return _has_bit(2);
}
inline void tinytable::clear_servercol() {
  if (servercol_ != &_default_servercol_) {
    servercol_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& tinytable::servercol() const {
  return *servercol_;
}
inline void tinytable::set_servercol(const ::std::string& value) {
  _set_bit(2);
  if (servercol_ == &_default_servercol_) {
    servercol_ = new ::std::string;
  }
  servercol_->assign(value);
}
inline void tinytable::set_servercol(const char* value) {
  _set_bit(2);
  if (servercol_ == &_default_servercol_) {
    servercol_ = new ::std::string;
  }
  servercol_->assign(value);
}
inline void tinytable::set_servercol(const char* value, size_t size) {
  _set_bit(2);
  if (servercol_ == &_default_servercol_) {
    servercol_ = new ::std::string;
  }
  servercol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tinytable::mutable_servercol() {
  _set_bit(2);
  if (servercol_ == &_default_servercol_) {
    servercol_ = new ::std::string;
  }
  return servercol_;
}

// required int32 expired = 4;
inline bool tinytable::has_expired() const {
  return _has_bit(3);
}
inline void tinytable::clear_expired() {
  expired_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 tinytable::expired() const {
  return expired_;
}
inline void tinytable::set_expired(::google::protobuf::int32 value) {
  _set_bit(3);
  expired_ = value;
}

// optional string loadtype = 5;
inline bool tinytable::has_loadtype() const {
  return _has_bit(4);
}
inline void tinytable::clear_loadtype() {
  if (loadtype_ != &_default_loadtype_) {
    loadtype_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& tinytable::loadtype() const {
  return *loadtype_;
}
inline void tinytable::set_loadtype(const ::std::string& value) {
  _set_bit(4);
  if (loadtype_ == &_default_loadtype_) {
    loadtype_ = new ::std::string;
  }
  loadtype_->assign(value);
}
inline void tinytable::set_loadtype(const char* value) {
  _set_bit(4);
  if (loadtype_ == &_default_loadtype_) {
    loadtype_ = new ::std::string;
  }
  loadtype_->assign(value);
}
inline void tinytable::set_loadtype(const char* value, size_t size) {
  _set_bit(4);
  if (loadtype_ == &_default_loadtype_) {
    loadtype_ = new ::std::string;
  }
  loadtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tinytable::mutable_loadtype() {
  _set_bit(4);
  if (loadtype_ == &_default_loadtype_) {
    loadtype_ = new ::std::string;
  }
  return loadtype_;
}

// optional string type = 6;
inline bool tinytable::has_type() const {
  return _has_bit(5);
}
inline void tinytable::clear_type() {
  if (type_ != &_default_type_) {
    type_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& tinytable::type() const {
  return *type_;
}
inline void tinytable::set_type(const ::std::string& value) {
  _set_bit(5);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void tinytable::set_type(const char* value) {
  _set_bit(5);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void tinytable::set_type(const char* value, size_t size) {
  _set_bit(5);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tinytable::mutable_type() {
  _set_bit(5);
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  return type_;
}

// optional string firstsource = 7;
inline bool tinytable::has_firstsource() const {
  return _has_bit(6);
}
inline void tinytable::clear_firstsource() {
  if (firstsource_ != &_default_firstsource_) {
    firstsource_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& tinytable::firstsource() const {
  return *firstsource_;
}
inline void tinytable::set_firstsource(const ::std::string& value) {
  _set_bit(6);
  if (firstsource_ == &_default_firstsource_) {
    firstsource_ = new ::std::string;
  }
  firstsource_->assign(value);
}
inline void tinytable::set_firstsource(const char* value) {
  _set_bit(6);
  if (firstsource_ == &_default_firstsource_) {
    firstsource_ = new ::std::string;
  }
  firstsource_->assign(value);
}
inline void tinytable::set_firstsource(const char* value, size_t size) {
  _set_bit(6);
  if (firstsource_ == &_default_firstsource_) {
    firstsource_ = new ::std::string;
  }
  firstsource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tinytable::mutable_firstsource() {
  _set_bit(6);
  if (firstsource_ == &_default_firstsource_) {
    firstsource_ = new ::std::string;
  }
  return firstsource_;
}

// optional string updatetype = 8;
inline bool tinytable::has_updatetype() const {
  return _has_bit(7);
}
inline void tinytable::clear_updatetype() {
  if (updatetype_ != &_default_updatetype_) {
    updatetype_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& tinytable::updatetype() const {
  return *updatetype_;
}
inline void tinytable::set_updatetype(const ::std::string& value) {
  _set_bit(7);
  if (updatetype_ == &_default_updatetype_) {
    updatetype_ = new ::std::string;
  }
  updatetype_->assign(value);
}
inline void tinytable::set_updatetype(const char* value) {
  _set_bit(7);
  if (updatetype_ == &_default_updatetype_) {
    updatetype_ = new ::std::string;
  }
  updatetype_->assign(value);
}
inline void tinytable::set_updatetype(const char* value, size_t size) {
  _set_bit(7);
  if (updatetype_ == &_default_updatetype_) {
    updatetype_ = new ::std::string;
  }
  updatetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tinytable::mutable_updatetype() {
  _set_bit(7);
  if (updatetype_ == &_default_updatetype_) {
    updatetype_ = new ::std::string;
  }
  return updatetype_;
}

// optional .tinytable.columns columns = 9;
inline bool tinytable::has_columns() const {
  return _has_bit(8);
}
inline void tinytable::clear_columns() {
  if (columns_ != NULL) columns_->::tinytable::columns::Clear();
  _clear_bit(8);
}
inline const ::tinytable::columns& tinytable::columns() const {
  return columns_ != NULL ? *columns_ : *default_instance_->columns_;
}
inline ::tinytable::columns* tinytable::mutable_columns() {
  _set_bit(8);
  if (columns_ == NULL) columns_ = new ::tinytable::columns;
  return columns_;
}

// optional .tinytable.uniques uniques = 10;
inline bool tinytable::has_uniques() const {
  return _has_bit(9);
}
inline void tinytable::clear_uniques() {
  if (uniques_ != NULL) uniques_->::tinytable::uniques::Clear();
  _clear_bit(9);
}
inline const ::tinytable::uniques& tinytable::uniques() const {
  return uniques_ != NULL ? *uniques_ : *default_instance_->uniques_;
}
inline ::tinytable::uniques* tinytable::mutable_uniques() {
  _set_bit(9);
  if (uniques_ == NULL) uniques_ = new ::tinytable::uniques;
  return uniques_;
}

// optional .tinytable.clusters clusters = 11;
inline bool tinytable::has_clusters() const {
  return _has_bit(10);
}
inline void tinytable::clear_clusters() {
  if (clusters_ != NULL) clusters_->::tinytable::clusters::Clear();
  _clear_bit(10);
}
inline const ::tinytable::clusters& tinytable::clusters() const {
  return clusters_ != NULL ? *clusters_ : *default_instance_->clusters_;
}
inline ::tinytable::clusters* tinytable::mutable_clusters() {
  _set_bit(10);
  if (clusters_ == NULL) clusters_ = new ::tinytable::clusters;
  return clusters_;
}

// optional .tinytable.sorts sorts = 12;
inline bool tinytable::has_sorts() const {
  return _has_bit(11);
}
inline void tinytable::clear_sorts() {
  if (sorts_ != NULL) sorts_->::tinytable::sorts::Clear();
  _clear_bit(11);
}
inline const ::tinytable::sorts& tinytable::sorts() const {
  return sorts_ != NULL ? *sorts_ : *default_instance_->sorts_;
}
inline ::tinytable::sorts* tinytable::mutable_sorts() {
  _set_bit(11);
  if (sorts_ == NULL) sorts_ = new ::tinytable::sorts;
  return sorts_;
}

// optional .tinytable.triggers triggers = 13;
inline bool tinytable::has_triggers() const {
  return _has_bit(12);
}
inline void tinytable::clear_triggers() {
  if (triggers_ != NULL) triggers_->::tinytable::triggers::Clear();
  _clear_bit(12);
}
inline const ::tinytable::triggers& tinytable::triggers() const {
  return triggers_ != NULL ? *triggers_ : *default_instance_->triggers_;
}
inline ::tinytable::triggers* tinytable::mutable_triggers() {
  _set_bit(12);
  if (triggers_ == NULL) triggers_ = new ::tinytable::triggers;
  return triggers_;
}

// optional .tinytable.queues queues = 14;
inline bool tinytable::has_queues() const {
  return _has_bit(13);
}
inline void tinytable::clear_queues() {
  if (queues_ != NULL) queues_->::tinytable::queues::Clear();
  _clear_bit(13);
}
inline const ::tinytable::queues& tinytable::queues() const {
  return queues_ != NULL ? *queues_ : *default_instance_->queues_;
}
inline ::tinytable::queues* tinytable::mutable_queues() {
  _set_bit(13);
  if (queues_ == NULL) queues_ = new ::tinytable::queues;
  return queues_;
}

// -------------------------------------------------------------------

// table

// required string name = 1;
inline bool table::has_name() const {
  return _has_bit(0);
}
inline void table::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& table::name() const {
  return *name_;
}
inline void table::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void table::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void table::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* table::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string update_type = 2;
inline bool table::has_update_type() const {
  return _has_bit(1);
}
inline void table::clear_update_type() {
  if (update_type_ != &_default_update_type_) {
    update_type_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& table::update_type() const {
  return *update_type_;
}
inline void table::set_update_type(const ::std::string& value) {
  _set_bit(1);
  if (update_type_ == &_default_update_type_) {
    update_type_ = new ::std::string;
  }
  update_type_->assign(value);
}
inline void table::set_update_type(const char* value) {
  _set_bit(1);
  if (update_type_ == &_default_update_type_) {
    update_type_ = new ::std::string;
  }
  update_type_->assign(value);
}
inline void table::set_update_type(const char* value, size_t size) {
  _set_bit(1);
  if (update_type_ == &_default_update_type_) {
    update_type_ = new ::std::string;
  }
  update_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* table::mutable_update_type() {
  _set_bit(1);
  if (update_type_ == &_default_update_type_) {
    update_type_ = new ::std::string;
  }
  return update_type_;
}

// optional int32 save = 3;
inline bool table::has_save() const {
  return _has_bit(2);
}
inline void table::clear_save() {
  save_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 table::save() const {
  return save_;
}
inline void table::set_save(::google::protobuf::int32 value) {
  _set_bit(2);
  save_ = value;
}

// -------------------------------------------------------------------

// tables

// repeated .tinytable.table table = 1;
inline int tables::table_size() const {
  return table_.size();
}
inline void tables::clear_table() {
  table_.Clear();
}
inline const ::tinytable::table& tables::table(int index) const {
  return table_.Get(index);
}
inline ::tinytable::table* tables::mutable_table(int index) {
  return table_.Mutable(index);
}
inline ::tinytable::table* tables::add_table() {
  return table_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::table >&
tables::table() const {
  return table_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::table >*
tables::mutable_table() {
  return &table_;
}

// -------------------------------------------------------------------

// tablecol

// required string name = 1;
inline bool tablecol::has_name() const {
  return _has_bit(0);
}
inline void tablecol::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& tablecol::name() const {
  return *name_;
}
inline void tablecol::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void tablecol::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void tablecol::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tablecol::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .tinytable.cols cols = 2;
inline bool tablecol::has_cols() const {
  return _has_bit(1);
}
inline void tablecol::clear_cols() {
  if (cols_ != NULL) cols_->::tinytable::cols::Clear();
  _clear_bit(1);
}
inline const ::tinytable::cols& tablecol::cols() const {
  return cols_ != NULL ? *cols_ : *default_instance_->cols_;
}
inline ::tinytable::cols* tablecol::mutable_cols() {
  _set_bit(1);
  if (cols_ == NULL) cols_ = new ::tinytable::cols;
  return cols_;
}

// -------------------------------------------------------------------

// tablecols

// repeated .tinytable.tablecol tablecol = 1;
inline int tablecols::tablecol_size() const {
  return tablecol_.size();
}
inline void tablecols::clear_tablecol() {
  tablecol_.Clear();
}
inline const ::tinytable::tablecol& tablecols::tablecol(int index) const {
  return tablecol_.Get(index);
}
inline ::tinytable::tablecol* tablecols::mutable_tablecol(int index) {
  return tablecol_.Mutable(index);
}
inline ::tinytable::tablecol* tablecols::add_tablecol() {
  return tablecol_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::tablecol >&
tablecols::tablecol() const {
  return tablecol_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::tablecol >*
tablecols::mutable_tablecol() {
  return &tablecol_;
}

// -------------------------------------------------------------------

// expire

// required string name = 1;
inline bool expire::has_name() const {
  return _has_bit(0);
}
inline void expire::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& expire::name() const {
  return *name_;
}
inline void expire::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void expire::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void expire::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* expire::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required int32 timeout = 2;
inline bool expire::has_timeout() const {
  return _has_bit(1);
}
inline void expire::clear_timeout() {
  timeout_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 expire::timeout() const {
  return timeout_;
}
inline void expire::set_timeout(::google::protobuf::int32 value) {
  _set_bit(1);
  timeout_ = value;
}

// required .tinytable.tablecols tablecols = 3;
inline bool expire::has_tablecols() const {
  return _has_bit(2);
}
inline void expire::clear_tablecols() {
  if (tablecols_ != NULL) tablecols_->::tinytable::tablecols::Clear();
  _clear_bit(2);
}
inline const ::tinytable::tablecols& expire::tablecols() const {
  return tablecols_ != NULL ? *tablecols_ : *default_instance_->tablecols_;
}
inline ::tinytable::tablecols* expire::mutable_tablecols() {
  _set_bit(2);
  if (tablecols_ == NULL) tablecols_ = new ::tinytable::tablecols;
  return tablecols_;
}

// -------------------------------------------------------------------

// expires

// repeated .tinytable.expire expire = 1;
inline int expires::expire_size() const {
  return expire_.size();
}
inline void expires::clear_expire() {
  expire_.Clear();
}
inline const ::tinytable::expire& expires::expire(int index) const {
  return expire_.Get(index);
}
inline ::tinytable::expire* expires::mutable_expire(int index) {
  return expire_.Mutable(index);
}
inline ::tinytable::expire* expires::add_expire() {
  return expire_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tinytable::expire >&
expires::expire() const {
  return expire_;
}
inline ::google::protobuf::RepeatedPtrField< ::tinytable::expire >*
expires::mutable_expire() {
  return &expire_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tinytable

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tinytable_2eproto__INCLUDED
